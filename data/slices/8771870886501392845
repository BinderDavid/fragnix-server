{"sliceID":8771870886501392845,"uses":[{"reference":{"otherSlice":4764577482525090158},"usedName":{"typeName":{"identifier":"Extract"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":1429932642700057250},"usedName":{"typeName":{"identifier":"MatchArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":2635897571898645267},"usedName":{"typeName":{"identifier":"MatchText"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"fmap"}},"qualification":null},{"reference":{"builtinModule":"Data.Tuple"},"usedName":{"valueName":{"identifier":"snd"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"isJust"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"builtinModule":"GHC.Arr"},"usedName":{"valueName":{"operator":"!"}},"qualification":null},{"reference":{"otherSlice":4764577482525090158},"usedName":{"valueName":{"identifier":"before"}},"qualification":null},{"reference":{"otherSlice":4764577482525090158},"usedName":{"valueName":{"identifier":"extract"}},"qualification":null},{"reference":{"otherSlice":4764577482525090158},"usedName":{"valueName":{"identifier":"after"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null}],"fragment":["class (Extract source) => RegexLike regex source where\n        matchOnce :: regex -> source -> Maybe MatchArray\n        \n        matchAll :: regex -> source -> [MatchArray]\n        \n        matchCount :: regex -> source -> Int\n        \n        matchTest :: regex -> source -> Bool\n        \n        matchAllText :: regex -> source -> [MatchText source]\n        \n        matchOnceText ::\n                      regex -> source -> Maybe (source, MatchText source, source)\n        matchAll regex source = map (fmap snd) (matchAllText regex source)\n        matchOnce regex source\n          = fmap (\\ (_, mt, _) -> fmap snd mt) (matchOnceText regex source)\n        matchTest regex source = isJust (matchOnce regex source)\n        matchCount regex source = length (matchAll regex source)\n        matchOnceText regex source\n          = fmap\n              (\\ ma ->\n                 let (o, l) = ma ! 0 in\n                   (before o source, fmap (\\ ol -> (extract ol source, ol)) ma,\n                    after (o + l) source))\n              (matchOnce regex source)\n        matchAllText regex source\n          = map (fmap (\\ ol -> (extract ol source, ol)))\n              (matchAll regex source)"],"instances":[{"instanceID":9212364612754854588,"instancePart":"OfThisClass"},{"instanceID":6639136938316660428,"instancePart":"OfThisClass"},{"instanceID":3512682504936062121,"instancePart":"OfThisClass"},{"instanceID":2893270655990506575,"instancePart":"OfThisClass"}],"language":{"extensions":["MultiParamTypeClasses","FunctionalDependencies","TypeSynonymInstances","FlexibleInstances","FlexibleContexts","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}