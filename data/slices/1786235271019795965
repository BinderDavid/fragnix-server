{"sliceID":1786235271019795965,"uses":[{"reference":{"otherSlice":4791260247128078865},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"minimum"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":8819855837653387286},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"quot"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"builtinModule":"GHC.Arr"},"usedName":{"valueName":{"identifier":"listArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"otherSlice":8499745574635551934},"usedName":{"valueName":{"identifier":"rehash1"}},"qualification":null},{"reference":{"otherSlice":1777456677057634181},"usedName":{"valueName":{"identifier":"rehash2"}},"qualification":null},{"reference":{"otherSlice":2433531944639182000},"usedName":{"valueName":{"identifier":"rehash3"}},"qualification":null},{"reference":{"otherSlice":7358526986585398087},"usedName":{"valueName":{"identifier":"rehash4"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":1661752722654164929},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"shiftL"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":1264447719843148261},"usedName":{"valueName":{"identifier":"take"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":null},{"reference":{"otherSlice":5707707704119147439},"usedName":{"valueName":{"identifier":"insertWith"}},"qualification":"IM"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"flip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"otherSlice":7359709951508731186},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"IM"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"zip"}},"qualification":null},{"reference":{"otherSlice":4345469173277560744},"usedName":{"valueName":{"identifier":"append"}},"qualification":"S"},{"reference":{"otherSlice":5578418172209195165},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":8068578393031383548},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"otherSlice":6396109612671124023},"usedName":{"valueName":{"identifier":"lookup"}},"qualification":"IM"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":1986893899592906745},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":404915850270007730},"usedName":{"valueName":{"identifier":"isPrefixOf"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"&&"}},"qualification":null},{"reference":{"otherSlice":7381193343906557358},"usedName":{"valueName":{"identifier":"checkFut"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"filter"}},"qualification":null},{"reference":{"otherSlice":7390130272431652744},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int64"}},"qualification":null}],"fragment":["lazyMatcher :: [S.ByteString] -> [S.ByteString] -> [(Int64, [Int])]","lazyMatcher pats = search 0 hLen S.empty\n  where !hLen = minimum (32 : map S.length pats)\n        !shDi\n          = case 32 `quot` hLen of\n                q | q < 4 -> q\n                  | otherwise -> 4\n        !outS = shDi * hLen\n        !patNum = length pats\n        !patArr = listArray (0, patNum - 1) pats\n        \n        {-# INLINE rehash #-}\n        \n        rehash :: Int -> Word8 -> Word8 -> Int\n        rehash\n          = case shDi of\n                1 -> rehash1 hLen\n                2 -> rehash2 outS\n                3 -> rehash3 outS\n                _ -> rehash4 outS\n        \n        hash :: S.ByteString -> Int\n        hash\n          = S.foldl' (\\ h w -> (h `shiftL` shDi) + fromIntegral w) 0 .\n              S.take hLen\n        !hashMap\n          = foldl' (\\ mp (h, i) -> IM.insertWith (flip (++)) h [i] mp)\n              IM.empty\n              $ zip (map hash pats) [0 :: Int ..]\n        search _ _ _ [] = []\n        search !h !rm !prev (!(str : rest))\n          | strLen < rm =\n            let !h' = S.foldl' (\\ o w -> (o `shiftL` 1) + fromIntegral w) h str\n                !prev' = S.append prev str\n              in search h' (rm - strLen) prev' rest\n          | otherwise =\n            let !h'\n                  = S.foldl' (\\ o w -> (o `shiftL` 1) + fromIntegral w) h\n                      (S.take rm str)\n              in\n              if S.null prev then noPast 0 rest str h' else\n                past 0 rest prev 0 str rm h'\n          where !strLen = S.length str\n        noPast !prior rest !str hsh = go hsh 0\n          where !strLen = S.length str\n                !maxIdx = strLen - hLen\n                \n                {-# INLINE strAt #-}\n                strAt !i = unsafeIndex str i\n                go !h sI\n                  = case IM.lookup h hashMap of\n                        Nothing -> if sI == maxIdx then\n                                     case rest of\n                                         [] -> []\n                                         (nxt : more) -> let !h'\n                                                               = rehash h (strAt sI)\n                                                                   (unsafeIndex nxt 0)\n                                                             !prior' = prior + fromIntegral strLen\n                                                             !prev = S.drop (sI + 1) str\n                                                           in\n                                                           if hLen == 1 then\n                                                             noPast prior' more nxt h' else\n                                                             past prior' more prev 0 nxt 1 h'\n                                     else go (rehash h (strAt sI) (strAt (sI + hLen))) (sI + 1)\n                        Just ps -> let !rst = S.drop sI str\n                                       !rLen = strLen - sI\n                                       \n                                       {-# INLINE hd #-}\n                                       hd = strAt sI\n                                       \n                                       {-# INLINE more #-}\n                                       more\n                                         = if sI == maxIdx then\n                                             case rest of\n                                                 [] -> []\n                                                 (nxt : fut) -> let !h'\n                                                                      = rehash h hd\n                                                                          (unsafeIndex nxt 0)\n                                                                    !prior'\n                                                                      = prior + fromIntegral strLen\n                                                                  in\n                                                                  if hLen == 1 then\n                                                                    noPast prior' fut nxt h' else\n                                                                    past prior' fut rst 1 nxt 1 h'\n                                             else go (rehash h hd (strAt (sI + hLen))) (sI + 1)\n                                       okay bs\n                                         | rLen < S.length bs =\n                                           S.isPrefixOf rst bs && checkFut (S.drop rLen bs) rest\n                                         | otherwise = S.isPrefixOf bs rst\n                                     in\n                                     case filter (okay . (patArr `unsafeAt`)) ps of\n                                         [] -> more\n                                         qs -> seq (length qs) $\n                                                 (prior + fromIntegral sI, qs) : more\n        past !prior rest !prev !pI !str !sI !hsh\n          | strLen < 4040 =\n            let !prior' = prior - 1 + fromIntegral (sI - hLen)\n                !curr = S.append (S.drop pI prev) str\n              in noPast prior' rest curr hsh\n          | otherwise = go hsh pI sI\n          where !strLen = S.length str\n                \n                {-# INLINE strAt #-}\n                strAt !i = unsafeIndex str i\n                \n                {-# INLINE prevAt #-}\n                prevAt !i = unsafeIndex prev i\n                go !h !p !s\n                  | s == hLen = noPast prior rest str h\n                  | otherwise =\n                    case IM.lookup h hashMap of\n                        Nothing -> let {-# INLINE h' #-}\n                                       h' = rehash h (prevAt p) (strAt s)\n                                     in go h' (p + 1) (s + 1)\n                        Just ps -> let !prst = S.drop p prev\n                                       \n                                       {-# INLINE more #-}\n                                       more = go (rehash h (prevAt p) (strAt s)) (p + 1) (s + 1)\n                                       okay bs = checkFut bs (prst : str : rest)\n                                     in\n                                     case filter (okay . (unsafeAt patArr)) ps of\n                                         [] -> more\n                                         qs -> seq (length qs) $\n                                                 (prior + fromIntegral (s - hLen), qs) : more"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}