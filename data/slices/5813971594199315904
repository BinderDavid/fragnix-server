{"sliceID":5813971594199315904,"uses":[{"reference":{"otherSlice":8530159555426240241},"usedName":{"valueName":{"identifier":"break"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":1986893899592906745},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"otherSlice":5578418172209195165},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":5030599164842377315},"usedName":{"valueName":{"identifier":"dropWhile"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Tuple"},"usedName":{"valueName":{"identifier":"fst"}},"qualification":null},{"reference":{"otherSlice":7764583337697008861},"usedName":{"valueName":{"identifier":"breakEnd"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"}],"fragment":["parseContentType ::\n                 S.ByteString -> (S.ByteString, [(S.ByteString, S.ByteString)])","parseContentType a\n  = do let (ctype, b) = S.break (== semicolon) a\n           attrs = goAttrs id $ S.drop 1 b\n         in (ctype, attrs)\n  where semicolon = 59\n        equals = 61\n        space = 32\n        goAttrs front bs\n          | S.null bs = front []\n          | otherwise =\n            let (x, rest) = S.break (== semicolon) bs in\n              goAttrs (front . (goAttr x :)) $ S.drop 1 rest\n        goAttr bs\n          = let (k, v') = S.break (== equals) bs\n                v = S.drop 1 v'\n              in (strip k, strip v)\n        strip = S.dropWhile (== space) . fst . S.breakEnd (/= space)"],"instances":[],"language":{"extensions":["OverloadedStrings","ExistentialQuantification","PatternGuards","TypeFamilies","RankNTypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"]}}