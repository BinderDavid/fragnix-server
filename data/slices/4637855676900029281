{"sliceID":4637855676900029281,"uses":[{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"min"}},"qualification":null},{"reference":{"otherSlice":6350502882776271008},"usedName":{"valueName":{"identifier":"createSmallArray"}},"qualification":null},{"reference":{"otherSlice":1336222803606167606},"usedName":{"valueName":{"identifier":"die"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"Data.Function"},"usedName":{"valueName":{"identifier":"fix"}},"qualification":null},{"reference":{"otherSlice":6305159245959420917},"usedName":{"valueName":{"operator":"?"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":3408757399140055139},"usedName":{"valueName":{"identifier":"writeSmallArray"}},"qualification":null},{"reference":{"otherSlice":5643076820601837867},"usedName":{"valueName":{"identifier":"indexSmallArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"*>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"String"}},"qualification":null},{"reference":{"otherSlice":6611341608342455607},"usedName":{"typeName":{"identifier":"SmallArray"}},"qualification":null}],"fragment":["zipW ::\n     String ->\n       (a -> b -> c) -> SmallArray a -> SmallArray b -> SmallArray c","zipW nm\n  = \\ f sa sb ->\n      let mn = length sa `min` length sb in\n        createSmallArray mn (die nm \"impossible\") $\n          \\ mc ->\n            fix ? 0 $\n              \\ go i ->\n                when (i < mn) $\n                  writeSmallArray mc i\n                    (f (indexSmallArray sa i) (indexSmallArray sb i))\n                    *> go (i + 1)"],"instances":[],"language":{"extensions":["MagicHash","RankNTypes","TypeFamilies","UnboxedTuples","DeriveTraversable","DeriveDataTypeable","GeneralizedNewtypeDeriving","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}