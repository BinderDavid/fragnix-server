{"sliceID":6097813107199612212,"uses":[{"reference":{"builtinModule":"Control.Monad.ST.Lazy"},"usedName":{"valueName":{"identifier":"runST"}},"qualification":null},{"reference":{"otherSlice":7987649984260342197},"usedName":{"valueName":{"identifier":"toChunks"}},"qualification":"L"},{"reference":{"otherSlice":7511316425710433924},"usedName":{"constructorName":{"identifier":"CompressInputRequired"},"constructorTypeName":{"identifier":"CompressStream"}},"qualification":null},{"reference":{"otherSlice":4791260247128078865},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"otherSlice":7511316425710433924},"usedName":{"constructorName":{"identifier":"CompressOutputAvailable"},"constructorTypeName":{"identifier":"CompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":7511316425710433924},"usedName":{"constructorName":{"identifier":"CompressStreamEnd"},"constructorTypeName":{"identifier":"CompressStream"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":7511316425710433924},"usedName":{"typeName":{"identifier":"CompressStream"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad.ST.Lazy"},"usedName":{"typeName":{"identifier":"ST"}},"qualification":null},{"reference":{"otherSlice":4192188388592563342},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"L"}],"fragment":["foldCompressStreamWithInput ::\n                            (S.ByteString -> a -> a) ->\n                              a -> (forall s . CompressStream (ST s)) -> L.ByteString -> a","foldCompressStreamWithInput chunk end\n  = \\ s lbs -> runST (fold s (L.toChunks lbs))\n  where fold (CompressInputRequired next) []\n          = next S.empty >>= \\ strm -> fold strm []\n        fold (CompressInputRequired next) (inchunk : inchunks)\n          = next inchunk >>= \\ s -> fold s inchunks\n        fold (CompressOutputAvailable outchunk next) inchunks\n          = do r <- next >>= \\ s -> fold s inchunks\n               return $ chunk outchunk r\n        fold CompressStreamEnd _inchunks = return end"],"instances":[],"language":{"extensions":["RankNTypes","DeriveDataTypeable","BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}