{"sliceID":2319966870973189622,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":2576674200041751378},"usedName":{"valueName":{"identifier":"powerArray"}},"qualification":null},{"reference":{"otherSlice":7390130272431652744},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":3881237054726774681},"usedName":{"valueName":{"identifier":"getByte"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".&."}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"operator":"^"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"testBit"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"otherSlice":4242350305663552248},"usedName":{"typeName":{"identifier":"ReadBuffer"}},"qualification":null}],"fragment":["decode :: Int -> Word8 -> ReadBuffer -> IO Int","decode n w rbuf\n  | i < p = return i\n  | otherwise = decode' 0 i\n  where !p = powerArray `unsafeAt` (n - 1)\n        !i = fromIntegral w\n        \n        decode' :: Int -> Int -> IO Int\n        decode' m j\n          = do !b <- fromIntegral <$> getByte rbuf\n               let !j' = j + (b .&. 127) * 2 ^ m\n                   !m' = m + 7\n                   !cont = b `testBit` 7\n               if cont then decode' m' j' else return j'"],"instances":[],"language":{"extensions":["BangPatterns","OverloadedStrings","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}