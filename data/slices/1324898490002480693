{"sliceID":1324898490002480693,"uses":[{"reference":{"otherSlice":3244558403807755735},"usedName":{"constructorName":{"identifier":"Context"},"constructorTypeName":{"identifier":"Context"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"outputQ"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"controlQ"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"connectionWindow"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"encodeDynamicTable"}},"qualification":null},{"reference":{"otherSlice":2455091088557061440},"usedName":{"constructorName":{"identifier":"Connection"},"constructorTypeName":{"identifier":"Connection"}},"qualification":null},{"reference":{"otherSlice":2455091088557061440},"usedName":{"valueName":{"identifier":"connWriteBuffer"}},"qualification":null},{"reference":{"otherSlice":2455091088557061440},"usedName":{"valueName":{"identifier":"connBufferSize"}},"qualification":null},{"reference":{"otherSlice":2455091088557061440},"usedName":{"valueName":{"identifier":"connSendAll"}},"qualification":null},{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"catch"}},"qualification":"E"},{"reference":{"otherSlice":8871291678177942613},"usedName":{"valueName":{"identifier":"isEmptyTQueue"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"valueName":{"identifier":"readTVar"}},"qualification":null},{"reference":{"otherSlice":5735093849006303241},"usedName":{"valueName":{"identifier":"check"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":960808331738935622},"usedName":{"valueName":{"identifier":"isEmptySTM"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":7953282282819253506},"usedName":{"constructorName":{"identifier":"Flush"},"constructorTypeName":{"identifier":"Switch"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"valueName":{"identifier":"retry"}},"qualification":null},{"reference":{"otherSlice":7953282282819253506},"usedName":{"constructorName":{"identifier":"O"},"constructorTypeName":{"identifier":"Switch"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":3388385851026458274},"usedName":{"valueName":{"identifier":"dequeueSTM"}},"qualification":null},{"reference":{"otherSlice":7953282282819253506},"usedName":{"constructorName":{"identifier":"C"},"constructorTypeName":{"identifier":"Switch"}},"qualification":null},{"reference":{"otherSlice":8404733269277475534},"usedName":{"valueName":{"identifier":"readTQueue"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"valueName":{"identifier":"atomically"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"otherSlice":272568700310874138},"usedName":{"valueName":{"identifier":"outputStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"otherSlice":686719806749404538},"usedName":{"valueName":{"identifier":"streamPrecedence"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":7606099774008308977},"usedName":{"constructorName":{"identifier":"CFinish"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"otherSlice":7606099774008308977},"usedName":{"constructorName":{"identifier":"CGoaway"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"otherSlice":7606099774008308977},"usedName":{"constructorName":{"identifier":"CFrame"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"otherSlice":7606099774008308977},"usedName":{"constructorName":{"identifier":"CSettings"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"otherSlice":7606099774008308977},"usedName":{"constructorName":{"identifier":"CSettings0"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":8819855837653387286},"usedName":{"valueName":{"identifier":"length"}},"qualification":"BS"},{"reference":{"otherSlice":8721526537659742777},"usedName":{"valueName":{"identifier":"copy"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"identifier":"void"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"lookup"}},"qualification":null},{"reference":{"otherSlice":6154917152996114215},"usedName":{"constructorName":{"identifier":"SettingsHeaderTableSize"},"constructorTypeName":{"identifier":"SettingsKeyId"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":1357233936490432890},"usedName":{"valueName":{"identifier":"setLimitForEncoding"}},"qualification":null},{"reference":{"otherSlice":272568700310874138},"usedName":{"constructorName":{"identifier":"Output"},"constructorTypeName":{"identifier":"Output"}},"qualification":null},{"reference":{"otherSlice":2773176672982378577},"usedName":{"constructorName":{"identifier":"ONext"},"constructorTypeName":{"identifier":"OutputType"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":2775146124478545809},"usedName":{"constructorName":{"identifier":"Next"},"constructorTypeName":{"identifier":"Next"}},"qualification":null},{"reference":{"otherSlice":2773176672982378577},"usedName":{"constructorName":{"identifier":"ORspn"},"constructorTypeName":{"identifier":"OutputType"}},"qualification":null},{"reference":{"otherSlice":686719806749404538},"usedName":{"valueName":{"identifier":"streamNumber"}},"qualification":null},{"reference":{"otherSlice":2511855293228854403},"usedName":{"constructorName":{"identifier":"RspnNobody"},"constructorTypeName":{"identifier":"Rspn"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":7285891009353472320},"usedName":{"valueName":{"identifier":"addNecessaryHeaders"}},"qualification":null},{"reference":{"otherSlice":2601220645498647911},"usedName":{"valueName":{"identifier":"frameHeaderLength"}},"qualification":null},{"reference":{"otherSlice":7196802242024295411},"usedName":{"valueName":{"identifier":"closed"}},"qualification":null},{"reference":{"otherSlice":2708228187031681692},"usedName":{"constructorName":{"identifier":"Finished"},"constructorTypeName":{"identifier":"ClosedCode"}},"qualification":null},{"reference":{"otherSlice":2511855293228854403},"usedName":{"constructorName":{"identifier":"RspnFile"},"constructorTypeName":{"identifier":"Rspn"}},"qualification":null},{"reference":{"otherSlice":6173254450505918756},"usedName":{"valueName":{"identifier":"fillFileBodyGetNext"}},"qualification":null},{"reference":{"otherSlice":2511855293228854403},"usedName":{"constructorName":{"identifier":"RspnBuilder"},"constructorTypeName":{"identifier":"Rspn"}},"qualification":null},{"reference":{"otherSlice":8325989485419181933},"usedName":{"valueName":{"identifier":"fillBuilderBodyGetNext"}},"qualification":null},{"reference":{"otherSlice":2511855293228854403},"usedName":{"constructorName":{"identifier":"RspnStreaming"},"constructorTypeName":{"identifier":"Rspn"}},"qualification":null},{"reference":{"otherSlice":3031510613313469796},"usedName":{"valueName":{"identifier":"fillStreamBodyGetNext"}},"qualification":null},{"reference":{"otherSlice":2773176672982378577},"usedName":{"constructorName":{"identifier":"OPush"},"constructorTypeName":{"identifier":"OutputType"}},"qualification":null},{"reference":{"otherSlice":272568700310874138},"usedName":{"valueName":{"identifier":"outputType"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"undefined"}},"qualification":null},{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"handle"}},"qualification":"E"},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"otherSlice":686719806749404538},"usedName":{"valueName":{"identifier":"streamState"}},"qualification":null},{"reference":{"otherSlice":8231620491642574232},"usedName":{"valueName":{"identifier":"isClosed"}},"qualification":null},{"reference":{"otherSlice":2773176672982378577},"usedName":{"constructorName":{"identifier":"OWait"},"constructorTypeName":{"identifier":"OutputType"}},"qualification":null},{"reference":{"otherSlice":272568700310874138},"usedName":{"valueName":{"identifier":"outputHook"}},"qualification":null},{"reference":{"otherSlice":8568339639895349521},"usedName":{"valueName":{"identifier":"forkAndEnqueueWhenReady"}},"qualification":null},{"reference":{"otherSlice":5940059896742285558},"usedName":{"valueName":{"identifier":"outputMaybeTBQueue"}},"qualification":null},{"reference":{"otherSlice":8358922810947306602},"usedName":{"valueName":{"identifier":"isEmptyTBQueue"}},"qualification":null},{"reference":{"otherSlice":3216768880165818172},"usedName":{"valueName":{"identifier":"waitStreaming"}},"qualification":null},{"reference":{"otherSlice":2322213875902821753},"usedName":{"valueName":{"identifier":"getStreamWindowSize"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":6212998143933129648},"usedName":{"valueName":{"identifier":"waitStreamWindowSize"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"min"}},"qualification":null},{"reference":{"otherSlice":2708228187031681692},"usedName":{"constructorName":{"identifier":"ResetByMe"},"constructorTypeName":{"identifier":"ClosedCode"}},"qualification":null},{"reference":{"otherSlice":8854238798879676744},"usedName":{"valueName":{"identifier":"resetFrame"}},"qualification":null},{"reference":{"otherSlice":4373455107983741140},"usedName":{"constructorName":{"identifier":"InternalError"},"constructorTypeName":{"identifier":"ErrorCodeId"}},"qualification":null},{"reference":{"otherSlice":7450610694038807841},"usedName":{"valueName":{"identifier":"enqueueControl"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":3525280260578742172},"usedName":{"valueName":{"identifier":"bufferIO"}},"qualification":null},{"reference":{"otherSlice":8676935357052086113},"usedName":{"valueName":{"identifier":"hpackEncodeHeader"}},"qualification":null},{"reference":{"otherSlice":2086591158824530143},"usedName":{"valueName":{"identifier":"setEndHeader"}},"qualification":null},{"reference":{"otherSlice":8349764978036283406},"usedName":{"valueName":{"identifier":"defaultFlags"}},"qualification":null},{"reference":{"otherSlice":9198359652752746411},"usedName":{"valueName":{"identifier":"setEndStream"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FrameHeaders"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":7616935046247181},"usedName":{"valueName":{"identifier":"hpackEncodeHeaderLoop"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"throwIO"}},"qualification":"E"},{"reference":{"otherSlice":209820424723097279},"usedName":{"constructorName":{"identifier":"ConnectionError"},"constructorTypeName":{"identifier":"HTTP2Error"}},"qualification":null},{"reference":{"otherSlice":4373455107983741140},"usedName":{"constructorName":{"identifier":"CompressionError"},"constructorTypeName":{"identifier":"ErrorCodeId"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FrameContinuation"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":272568700310874138},"usedName":{"typeName":{"identifier":"Output"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":2775146124478545809},"usedName":{"typeName":{"identifier":"DynaNext"}},"qualification":null},{"reference":{"otherSlice":4406646487968172397},"usedName":{"valueName":{"identifier":"enqueueOutput"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":686719806749404538},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":686719806749404538},"usedName":{"valueName":{"identifier":"streamWindow"}},"qualification":null},{"reference":{"otherSlice":6883051797763074494},"usedName":{"valueName":{"identifier":"http2dataTrailers"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"isNothing"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"&&"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FrameData"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":382158153918373714},"usedName":{"valueName":{"identifier":"modifyTVar'"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"identifier":"subtract"}},"qualification":null},{"reference":{"otherSlice":866162753350440556},"usedName":{"valueName":{"identifier":"toHeaderTable"}},"qualification":null},{"reference":{"otherSlice":1852351943867495386},"usedName":{"valueName":{"identifier":"poke32"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FramePushPromise"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":5166554293679612415},"usedName":{"valueName":{"identifier":"encodeFrameHeaderBuf"}},"qualification":null},{"reference":{"otherSlice":7980604682421784157},"usedName":{"constructorName":{"identifier":"FrameHeader"},"constructorTypeName":{"identifier":"FrameHeader"}},"qualification":null},{"reference":{"builtinModule":"GHC.Exception"},"usedName":{"typeName":{"identifier":"SomeException"}},"qualification":"E"},{"reference":{"otherSlice":3244558403807755735},"usedName":{"typeName":{"identifier":"Context"}},"qualification":null},{"reference":{"otherSlice":2455091088557061440},"usedName":{"typeName":{"identifier":"Connection"}},"qualification":null},{"reference":{"otherSlice":7471038449729235448},"usedName":{"typeName":{"identifier":"Settings"}},"qualification":"S"},{"reference":{"otherSlice":546518555448962890},"usedName":{"typeName":{"identifier":"Manager"}},"qualification":null}],"fragment":["frameSender ::\n            Context -> Connection -> S.Settings -> Manager -> IO ()","frameSender\n  ctx@Context{outputQ, controlQ, connectionWindow,\n              encodeDynamicTable}\n  conn@Connection{connWriteBuffer, connBufferSize, connSendAll}\n  settings mgr = loop 0 `E.catch` ignore\n  where dequeue off\n          = do isEmpty <- isEmptyTQueue controlQ\n               if isEmpty then\n                 do w <- readTVar connectionWindow\n                    check (w > 0)\n                    emp <- isEmptySTM outputQ\n                    if emp then if off /= 0 then return Flush else retry else\n                      O <$> dequeueSTM outputQ\n                 else C <$> readTQueue controlQ\n        loop off\n          = do x <- atomically $ dequeue off\n               case x of\n                   C ctl -> do when (off /= 0) $ flushN off\n                               off' <- control ctl off\n                               when (off' >= 0) $ loop off'\n                   O (_, pre, out) -> do let strm = outputStream out\n                                         writeIORef (streamPrecedence strm) pre\n                                         off' <- outputOrEnqueueAgain out off\n                                         case off' of\n                                             0 -> loop 0\n                                             _ | off' > 15872 -> flushN off' >> loop 0\n                                               | otherwise -> loop off'\n                   Flush -> flushN off >> loop 0\n        control CFinish _ = return (-1)\n        control (CGoaway frame) _ = connSendAll frame >> return (-1)\n        control (CFrame frame) _ = connSendAll frame >> return 0\n        control (CSettings frame alist) _\n          = do connSendAll frame\n               setLimit alist\n               return 0\n        control (CSettings0 frame1 frame2 alist) off\n          = do let !buf = connWriteBuffer `plusPtr` off\n                   !off' = off + BS.length frame1 + BS.length frame2\n               buf' <- copy buf frame1\n               void $ copy buf' frame2\n               setLimit alist\n               return off'\n        \n        {-# INLINE setLimit #-}\n        setLimit alist\n          = case lookup SettingsHeaderTableSize alist of\n                Nothing -> return ()\n                Just siz -> setLimitForEncoding siz encodeDynamicTable\n        output out@(Output strm _ _ tell getH2D (ONext curr)) off0 lim\n          = do let !buf = connWriteBuffer `plusPtr` off0\n                   !siz = connBufferSize - off0\n               Next datPayloadLen mnext <- curr buf siz lim\n               off <- fillDataHeader strm off0 datPayloadLen mnext tell getH2D\n               maybeEnqueueNext out mnext\n               return off\n        output out@(Output strm rspn ii tell getH2D ORspn) off0 lim\n          = do let !sid = streamNumber strm\n                   !endOfStream\n                     = case rspn of\n                           RspnNobody _ _ -> True\n                           _ -> False\n               ths <- addNecessaryHeaders ctx rspn ii settings\n               kvlen <- headerContinue sid ths endOfStream off0\n               off <- sendHeadersIfNecessary $ off0 + frameHeaderLength + kvlen\n               case rspn of\n                   RspnNobody _ _ -> do closed ctx strm Finished\n                                        return off\n                   RspnFile _ _ path mpart -> do let payloadOff\n                                                       = off + frameHeaderLength\n                                                 Next datPayloadLen mnext <- fillFileBodyGetNext\n                                                                               conn\n                                                                               ii\n                                                                               payloadOff\n                                                                               lim\n                                                                               path\n                                                                               mpart\n                                                 off' <- fillDataHeader strm off datPayloadLen mnext\n                                                           tell\n                                                           getH2D\n                                                 maybeEnqueueNext out mnext\n                                                 return off'\n                   RspnBuilder _ _ builder -> do let payloadOff\n                                                       = off + frameHeaderLength\n                                                 Next datPayloadLen mnext <- fillBuilderBodyGetNext\n                                                                               conn\n                                                                               ii\n                                                                               payloadOff\n                                                                               lim\n                                                                               builder\n                                                 off' <- fillDataHeader strm off datPayloadLen mnext\n                                                           tell\n                                                           getH2D\n                                                 maybeEnqueueNext out mnext\n                                                 return off'\n                   RspnStreaming _ _ tbq -> do let payloadOff\n                                                     = off + frameHeaderLength\n                                               Next datPayloadLen mnext <- fillStreamBodyGetNext\n                                                                             conn\n                                                                             payloadOff\n                                                                             lim\n                                                                             tbq\n                                                                             strm\n                                               off' <- fillDataHeader strm off datPayloadLen mnext\n                                                         tell\n                                                         getH2D\n                                               maybeEnqueueNext out mnext\n                                               return off'\n        output out@(Output strm _ _ _ _ (OPush ths pid)) off0 lim\n          = do let !sid = streamNumber strm\n               len <- pushPromise pid sid ths off0\n               off <- sendHeadersIfNecessary $ off0 + frameHeaderLength + len\n               output out{outputType = ORspn} off lim\n        output _ _ _ = undefined\n        outputOrEnqueueAgain out off\n          = E.handle resetStream $\n              do state <- readIORef $ streamState strm\n                 if isClosed state then return off else\n                   case out of\n                       Output _ _ _ wait _ OWait -> do let out'\n                                                             = out{outputHook = return (),\n                                                                   outputType = ORspn}\n                                                       forkAndEnqueueWhenReady wait outputQ out' mgr\n                                                       return off\n                       _ -> case mtbq of\n                                Just tbq -> checkStreaming tbq\n                                _ -> checkStreamWindowSize\n          where strm = outputStream out\n                mtbq = outputMaybeTBQueue out\n                checkStreaming tbq\n                  = do isEmpty <- atomically $ isEmptyTBQueue tbq\n                       if isEmpty then\n                         do forkAndEnqueueWhenReady (waitStreaming tbq) outputQ out mgr\n                            return off\n                         else checkStreamWindowSize\n                checkStreamWindowSize\n                  = do sws <- getStreamWindowSize strm\n                       if sws == 0 then\n                         do forkAndEnqueueWhenReady (waitStreamWindowSize strm) outputQ out\n                              mgr\n                            return off\n                         else\n                         do cws <- atomically $ readTVar connectionWindow\n                            let !lim = min cws sws\n                            output out off lim\n                resetStream e\n                  = do closed ctx strm (ResetByMe e)\n                       let !rst = resetFrame InternalError $ streamNumber strm\n                       enqueueControl controlQ $ CFrame rst\n                       return off\n        \n        {-# INLINE flushN #-}\n        \n        flushN :: Int -> IO ()\n        flushN n = bufferIO connWriteBuffer n connSendAll\n        headerContinue sid ths endOfStream off\n          = do let !offkv = off + frameHeaderLength\n               let !bufkv = connWriteBuffer `plusPtr` offkv\n                   !limkv = connBufferSize - offkv\n               (hs, kvlen) <- hpackEncodeHeader ctx bufkv limkv ths\n               let flag0\n                     = case hs of\n                           [] -> setEndHeader defaultFlags\n                           _ -> defaultFlags\n                   flag = if endOfStream then setEndStream flag0 else flag0\n               let buf = connWriteBuffer `plusPtr` off\n               fillFrameHeader FrameHeaders kvlen sid flag buf\n               continue sid kvlen hs\n        !bufHeaderPayload = connWriteBuffer `plusPtr` frameHeaderLength\n        !headerPayloadLim = connBufferSize - frameHeaderLength\n        continue _ kvlen [] = return kvlen\n        continue sid kvlen ths\n          = do flushN $ kvlen + frameHeaderLength\n               (ths', kvlen') <- hpackEncodeHeaderLoop ctx bufHeaderPayload\n                                   headerPayloadLim\n                                   ths\n               when (ths == ths') $\n                 E.throwIO $\n                   ConnectionError CompressionError \"cannot compress the header\"\n               let flag\n                     = case ths' of\n                           [] -> setEndHeader defaultFlags\n                           _ -> defaultFlags\n               fillFrameHeader FrameContinuation kvlen' sid flag connWriteBuffer\n               continue sid kvlen' ths'\n        \n        {-# INLINE maybeEnqueueNext #-}\n        \n        maybeEnqueueNext :: Output -> Maybe DynaNext -> IO ()\n        maybeEnqueueNext _ Nothing = return ()\n        maybeEnqueueNext out (Just next) = enqueueOutput outputQ out'\n          where !out' = out{outputType = ONext next}\n        \n        {-# INLINE sendHeadersIfNecessary #-}\n        sendHeadersIfNecessary off\n          | off + frameHeaderLength < connBufferSize = return off\n          | otherwise =\n            do flushN off\n               return 0\n        fillDataHeader strm@Stream{streamWindow, streamNumber} off\n          datPayloadLen mnext tell getH2D\n          = do mh2d <- getH2D\n               let (!trailers, !noTrailers)\n                     = case http2dataTrailers <$> mh2d of\n                           Nothing -> ([], True)\n                           Just ts -> (ts, null ts)\n                   !buf = connWriteBuffer `plusPtr` off\n                   !off' = off + frameHeaderLength + datPayloadLen\n                   !noMoreBody = isNothing mnext\n                   flag\n                     | noMoreBody && noTrailers = setEndStream defaultFlags\n                     | otherwise = defaultFlags\n               fillFrameHeader FrameData datPayloadLen streamNumber flag buf\n               off'' <- handleEndOfBody noMoreBody off' noTrailers trailers\n               atomically $ modifyTVar' connectionWindow (subtract datPayloadLen)\n               atomically $ modifyTVar' streamWindow (subtract datPayloadLen)\n               return off''\n          where handleTrailers True off0 _ = return off0\n                handleTrailers _ off0 trailers\n                  = do (ths, _) <- toHeaderTable trailers\n                       kvlen <- headerContinue streamNumber ths True off0\n                       sendHeadersIfNecessary $ off0 + frameHeaderLength + kvlen\n                handleEndOfBody True off0 noTrailers trailers\n                  = do off1 <- handleTrailers noTrailers off0 trailers\n                       void $ tell\n                       closed ctx strm Finished\n                       return off1\n                handleEndOfBody False off0 _ _ = return off0\n        pushPromise pid sid ths off\n          = do let !offsid = off + frameHeaderLength\n                   !bufsid = connWriteBuffer `plusPtr` offsid\n               poke32 bufsid $ fromIntegral sid\n               let !offkv = offsid + 4\n                   !bufkv = connWriteBuffer `plusPtr` offkv\n                   !limkv = connBufferSize - offkv\n               (_, kvlen) <- hpackEncodeHeader ctx bufkv limkv ths\n               let !flag = setEndHeader defaultFlags\n                   !buf = connWriteBuffer `plusPtr` off\n                   !len = kvlen + 4\n               fillFrameHeader FramePushPromise len pid flag buf\n               return len\n        \n        {-# INLINE fillFrameHeader #-}\n        fillFrameHeader ftyp len sid flag buf\n          = encodeFrameHeaderBuf ftyp hinfo buf\n          where hinfo = FrameHeader len flag sid\n        \n        {-# INLINE ignore #-}\n        \n        ignore :: E.SomeException -> IO ()\n        ignore _ = return ()"],"instances":[],"language":{"extensions":["OverloadedStrings","BangPatterns","NamedFieldPuns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}