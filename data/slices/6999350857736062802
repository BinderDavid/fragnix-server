{"sliceID":6999350857736062802,"uses":[{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"typeName":{"identifier":"Ptr"}},"qualification":null},{"reference":{"otherSlice":1485990264948053636},"usedName":{"typeName":{"identifier":"CRegex"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.String"},"usedName":{"typeName":{"identifier":"CString"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Types"},"usedName":{"typeName":{"identifier":"CSize"}},"qualification":null},{"reference":{"otherSlice":5401520117453799886},"usedName":{"typeName":{"identifier":"CRegMatch"}},"qualification":null},{"reference":{"otherSlice":6024572806983767782},"usedName":{"typeName":{"identifier":"ExecOption"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"typeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":7099028456858277446},"usedName":{"typeName":{"identifier":"WrapError"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":3292959396506062126},"usedName":{"typeName":{"identifier":"RegOffset"}},"qualification":null},{"reference":{"otherSlice":5306860388721937318},"usedName":{"valueName":{"identifier":"c_regexec"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":5580876852595760176},"usedName":{"valueName":{"identifier":"retOk"}},"qualification":null},{"reference":{"builtinModule":"Data.Traversable"},"usedName":{"valueName":{"identifier":"mapM"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"take"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"iterate"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":1313948177237351719},"usedName":{"valueName":{"identifier":"retNoMatch"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":8328749365935494164},"usedName":{"valueName":{"identifier":"wrapError"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"peekByteOff"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int32"}},"qualification":null}],"fragment":["doMatch ::\n        Ptr CRegex ->\n          CString ->\n            CSize ->\n              Ptr CRegMatch ->\n                ExecOption ->\n                  IO (Either WrapError (Maybe [(RegOffset, RegOffset)]))","doMatch regex_ptr cstr nsub p_match flags\n  = do r <- c_regexec regex_ptr cstr (1 + nsub) p_match flags\n       if r == retOk then\n         do regions <- mapM getOffsets .\n                         take (1 + fromIntegral nsub) . iterate (`plusPtr` (8))\n                         $ p_match\n            return (Right (Just regions))\n         else\n         if r == retNoMatch then return (Right Nothing) else\n           wrapError r regex_ptr\n  where getOffsets :: Ptr CRegMatch -> IO (RegOffset, RegOffset)\n        \n        {-# INLINE getOffsets #-}\n        getOffsets pmatch'\n          = do start <- ((\\ hsc_ptr -> peekByteOff hsc_ptr 0)) pmatch' ::\n                          IO (Int32)\n               end <- ((\\ hsc_ptr -> peekByteOff hsc_ptr 4)) pmatch' :: IO (Int32)\n               return (fromIntegral start, fromIntegral end)"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","FunctionalDependencies","ForeignFunctionInterface","GeneralizedNewtypeDeriving","FlexibleContexts","TypeSynonymInstances","FlexibleInstances","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}