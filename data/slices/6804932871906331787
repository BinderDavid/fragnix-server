{"sliceID":6804932871906331787,"uses":[{"reference":{"otherSlice":1684953695762370946},"usedName":{"constructorName":{"identifier":"C"},"constructorTypeName":{"identifier":"Get"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":1684953695762370946},"usedName":{"valueName":{"identifier":"runCont"}},"qualification":null},{"reference":{"otherSlice":983928231933241689},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Decoder"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"reverse"}},"qualification":null},{"reference":{"otherSlice":983928231933241689},"usedName":{"constructorName":{"identifier":"Partial"},"constructorTypeName":{"identifier":"Decoder"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"maybe"}},"qualification":null},{"reference":{"otherSlice":983928231933241689},"usedName":{"constructorName":{"identifier":"Fail"},"constructorTypeName":{"identifier":"Decoder"}},"qualification":null},{"reference":{"otherSlice":983928231933241689},"usedName":{"constructorName":{"identifier":"BytesRead"},"constructorTypeName":{"identifier":"Decoder"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":1684953695762370946},"usedName":{"typeName":{"identifier":"Get"}},"qualification":null},{"reference":{"otherSlice":983928231933241689},"usedName":{"typeName":{"identifier":"Decoder"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"B"}],"fragment":["runAndKeepTrack :: Get a -> Get (Decoder a, [B.ByteString])","runAndKeepTrack g\n  = C $\n      \\ inp ks ->\n        let r0 = runCont g inp (\\ inp' a -> Done inp' a)\n            go !acc r\n              = case r of\n                    Done inp' a -> ks inp (Done inp' a, reverse acc)\n                    Partial k -> Partial $\n                                   \\ minp -> go (maybe acc (: acc) minp) (k minp)\n                    Fail inp' s -> ks inp (Fail inp' s, reverse acc)\n                    BytesRead unused k -> BytesRead unused (go acc . k)\n          in go [] r0"],"instances":[],"language":{"extensions":["RankNTypes","MagicHash","BangPatterns","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}