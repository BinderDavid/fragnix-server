{"sliceID":2340965571009052300,"uses":[{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Applicative"}},"qualification":null},{"reference":{"otherSlice":6423202506202804909},"usedName":{"typeName":{"identifier":"Array"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"pure"}},"qualification":null},{"reference":{"builtinModule":"GHC.ST"},"usedName":{"valueName":{"identifier":"runST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":1240416926497088270},"usedName":{"valueName":{"identifier":"newArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"otherSlice":4622782793871476184},"usedName":{"valueName":{"identifier":"unsafeFreezeArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"<*>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"otherSlice":2421956646851686629},"usedName":{"valueName":{"identifier":"die"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":3184645393199691518},"usedName":{"valueName":{"identifier":"indexArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":1080947357764179124},"usedName":{"valueName":{"identifier":"writeArray"}},"qualification":null},{"reference":{"otherSlice":3535168395517515397},"usedName":{"valueName":{"identifier":"sizeofArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"*>"}},"qualification":null},{"reference":{"otherSlice":7612126003716308710},"usedName":{"valueName":{"identifier":"createArray"}},"qualification":null},{"reference":{"otherSlice":1917744042732152598},"usedName":{"valueName":{"identifier":"copyArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"<*"}},"qualification":null}],"fragment":["instance Applicative Array where\n        pure x = runST $ newArray 1 x >>= unsafeFreezeArray\n        ab <*> a\n          = runST $\n              do mb <- newArray (szab * sza) $ die \"<*>\" \"impossible\"\n                 let go1 i\n                       | i < szab = go2 (i * sza) (indexArray ab i) 0 >> go1 (i + 1)\n                       | otherwise = return ()\n                     go2 off f j\n                       | j < sza = writeArray mb (off + j) (f $ indexArray a j)\n                       | otherwise = return ()\n                 go1 0\n                 unsafeFreezeArray mb\n          where szab = sizeofArray ab\n                sza = sizeofArray a\n        a *> b\n          = createArray (sza * szb) (die \"*>\" \"impossible\") $\n              \\ mb ->\n                let go i\n                      | i < sza = copyArray mb (i * szb) b 0 szb\n                      | otherwise = return ()\n                  in go 0\n          where sza = sizeofArray a\n                szb = sizeofArray b\n        a <* b\n          = createArray (sza * szb) (die \"<*\" \"impossible\") $\n              \\ ma ->\n                let fill off i e\n                      | i < szb = writeArray ma (off + i) e >> fill off (i + 1) e\n                      | otherwise = return ()\n                    go i\n                      | i < sza = fill (i * szb) 0 (indexArray a i) >> go (i + 1)\n                      | otherwise = return ()\n                  in go 0\n          where sza = sizeofArray a\n                szb = sizeofArray b"],"instances":[],"language":{"extensions":["MagicHash","UnboxedTuples","DeriveDataTypeable","BangPatterns","RankNTypes","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}