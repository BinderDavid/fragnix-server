{"sliceID":5834745260650911563,"uses":[{"reference":{"otherSlice":2912204013472023076},"usedName":{"constructorName":{"identifier":"CSource"},"constructorTypeName":{"identifier":"CSource"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":"I"},{"reference":{"otherSlice":4018775593934308134},"usedName":{"valueName":{"identifier":"leftoverSource"}},"qualification":null},{"reference":{"otherSlice":4791260247128078865},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"otherSlice":6503732381371016449},"usedName":{"constructorName":{"identifier":"DoneChunking"},"constructorTypeName":{"identifier":"ChunkState"}},"qualification":null},{"reference":{"otherSlice":5578418172209195165},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":"I"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":8819855837653387286},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"compare"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"EQ"},"constructorTypeName":{"identifier":"Ordering"}},"qualification":null},{"reference":{"otherSlice":6503732381371016449},"usedName":{"constructorName":{"identifier":"NeedLenNewline"},"constructorTypeName":{"identifier":"ChunkState"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"LT"},"constructorTypeName":{"identifier":"Ordering"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":6503732381371016449},"usedName":{"constructorName":{"identifier":"HaveLen"},"constructorTypeName":{"identifier":"ChunkState"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"GT"},"constructorTypeName":{"identifier":"Ordering"}},"qualification":null},{"reference":{"otherSlice":3092570537208454296},"usedName":{"valueName":{"identifier":"splitAt"}},"qualification":"S"},{"reference":{"otherSlice":3073900091224728213},"usedName":{"valueName":{"identifier":"readSource"}},"qualification":null},{"reference":{"otherSlice":8592546851761716},"usedName":{"valueName":{"identifier":"uncons"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":2441274640222363113},"usedName":{"valueName":{"identifier":"readSource'"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"unless"}},"qualification":null},{"reference":{"otherSlice":6503732381371016449},"usedName":{"constructorName":{"identifier":"NeedLen"},"constructorTypeName":{"identifier":"ChunkState"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"assert"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":8530159555426240241},"usedName":{"valueName":{"identifier":"break"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":4345469173277560744},"usedName":{"valueName":{"identifier":"append"}},"qualification":"S"},{"reference":{"otherSlice":1661752722654164929},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":4067596533135708555},"usedName":{"valueName":{"identifier":"takeWhile"}},"qualification":"S"},{"reference":{"otherSlice":6630589635919859672},"usedName":{"valueName":{"identifier":"isHexDigit"}},"qualification":null},{"reference":{"otherSlice":1986893899592906745},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":2912204013472023076},"usedName":{"typeName":{"identifier":"CSource"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null}],"fragment":["readCSource :: CSource -> IO ByteString","readCSource (CSource src ref)\n  = do mlen <- I.readIORef ref\n       go mlen\n  where withLen 0 bs\n          = do leftoverSource src bs\n               dropCRLF\n               yield' S.empty DoneChunking\n        withLen len bs\n          | S.null bs =\n            do I.writeIORef ref DoneChunking\n               return S.empty\n          | otherwise =\n            case S.length bs `compare` fromIntegral len of\n                EQ -> yield' bs NeedLenNewline\n                LT -> yield' bs $ HaveLen $ len - fromIntegral (S.length bs)\n                GT -> do let (x, y) = S.splitAt (fromIntegral len) bs\n                         leftoverSource src y\n                         yield' x NeedLenNewline\n        yield' bs mlen\n          = do I.writeIORef ref mlen\n               return bs\n        dropCRLF\n          = do bs <- readSource src\n               case S.uncons bs of\n                   Nothing -> return ()\n                   Just (13, bs') -> dropLF bs'\n                   Just (10, bs') -> leftoverSource src bs'\n                   Just _ -> leftoverSource src bs\n        dropLF bs\n          = case S.uncons bs of\n                Nothing -> do bs2 <- readSource' src\n                              unless (S.null bs2) $ dropLF bs2\n                Just (10, bs') -> leftoverSource src bs'\n                Just _ -> leftoverSource src bs\n        go NeedLen = getLen\n        go NeedLenNewline = dropCRLF >> getLen\n        go (HaveLen 0)\n          = do dropCRLF\n               I.writeIORef ref DoneChunking\n               return S.empty\n        go (HaveLen len)\n          = do bs <- readSource src\n               withLen len bs\n        go DoneChunking = return S.empty\n        getLen\n          = do bs <- readSource src\n               if S.null bs then\n                 do I.writeIORef ref $ assert False $ HaveLen 0\n                    return S.empty\n                 else\n                 do (x, y) <- case S.break (== 10) bs of\n                                  (x, y) | S.null y ->\n                                           do bs2 <- readSource' src\n                                              return $\n                                                if S.null bs2 then (x, y) else\n                                                  S.break (== 10) $ bs `S.append` bs2\n                                         | otherwise -> return (x, y)\n                    let w = S.foldl' (\\ i c -> i * 16 + fromIntegral (hexToWord c)) 0 $\n                              S.takeWhile isHexDigit x\n                    let y' = S.drop 1 y\n                    y'' <- if S.null y' then readSource src else return y'\n                    withLen w y''\n        hexToWord w\n          | w < 58 = w - 48\n          | w < 71 = w - 55\n          | otherwise = w - 87"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}