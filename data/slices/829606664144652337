{"sliceID":829606664144652337,"uses":[{"reference":{"otherSlice":7927641156243649111},"usedName":{"constructorName":{"identifier":"DecompressInputRequired"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":6440141602958235187},"usedName":{"valueName":{"identifier":"mkStateIO"}},"qualification":null},{"reference":{"otherSlice":167240354354344250},"usedName":{"valueName":{"identifier":"decompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":4165068993331019704},"usedName":{"valueName":{"identifier":"runStreamIO"}},"qualification":null},{"reference":{"otherSlice":5578418172209195165},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":7927641156243649111},"usedName":{"typeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":125078826469118394},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":8686746673302569493},"usedName":{"typeName":{"identifier":"State"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"typeName":{"identifier":"RealWorld"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":7927641156243649111},"usedName":{"constructorName":{"identifier":"DecompressOutputAvailable"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":7927641156243649111},"usedName":{"constructorName":{"identifier":"DecompressStreamEnd"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":3999331852237552717},"usedName":{"valueName":{"identifier":"gzipFormat"}},"qualification":"Stream"},{"reference":{"otherSlice":5574456052860446799},"usedName":{"valueName":{"identifier":"decompressAllMembers"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":7927641156243649111},"usedName":{"constructorName":{"identifier":"DecompressStreamError"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":8819855837653387286},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"otherSlice":4791260247128078865},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"otherSlice":7849470518260417306},"usedName":{"valueName":{"identifier":"head"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":2720615151363074449},"usedName":{"valueName":{"identifier":"pack"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":3341765212252452435},"usedName":{"valueName":{"identifier":"tail"}},"qualification":"S"},{"reference":{"otherSlice":5820673369487990862},"usedName":{"valueName":{"identifier":"cons"}},"qualification":"S"},{"reference":{"otherSlice":6381574974755886985},"usedName":{"valueName":{"identifier":"index"}},"qualification":"S"},{"reference":{"otherSlice":1703996068210287062},"usedName":{"valueName":{"identifier":"finalise"}},"qualification":"Stream"},{"reference":{"otherSlice":4182049159116233466},"usedName":{"typeName":{"identifier":"Format"}},"qualification":"Stream"},{"reference":{"otherSlice":5574456052860446799},"usedName":{"typeName":{"identifier":"DecompressParams"}},"qualification":null}],"fragment":["decompressStreamIO ::\n                   Stream.Format -> DecompressParams -> DecompressStream IO","decompressStreamIO format params\n  = DecompressInputRequired $\n      \\ chunk ->\n        do zstate <- mkStateIO\n           let next = decompressStream format params False\n           (strm', zstate') <- runStreamIO (next chunk) zstate\n           go strm' zstate' (S.null chunk)\n  where go ::\n           DecompressStream Stream ->\n             Stream.State RealWorld -> Bool -> IO (DecompressStream IO)\n        go (DecompressInputRequired next) zstate !_\n          = return $\n              DecompressInputRequired $\n                \\ chunk ->\n                  do (strm', zstate') <- runStreamIO (next chunk) zstate\n                     go strm' zstate' (S.null chunk)\n        go (DecompressOutputAvailable chunk next) zstate !eof\n          = return $\n              DecompressOutputAvailable chunk $\n                do (strm', zstate') <- runStreamIO next zstate\n                   go strm' zstate' eof\n        go (DecompressStreamEnd unconsumed) zstate !eof\n          | format == Stream.gzipFormat, decompressAllMembers params, not eof\n            = tryFollowingStream unconsumed zstate\n          | otherwise = finaliseStreamEnd unconsumed zstate\n        go (DecompressStreamError err) zstate !_\n          = finaliseStreamError err zstate\n        \n        tryFollowingStream ::\n                           S.ByteString -> Stream.State RealWorld -> IO (DecompressStream IO)\n        tryFollowingStream chunk zstate\n          = case S.length chunk of\n                0 -> return $\n                       DecompressInputRequired $\n                         \\ chunk' ->\n                           case S.length chunk' of\n                               0 -> finaliseStreamEnd S.empty zstate\n                               1 | S.head chunk' /= 31 -> finaliseStreamEnd chunk' zstate\n                               1 -> return $\n                                      DecompressInputRequired $\n                                        \\ chunk'' ->\n                                          case S.length chunk'' of\n                                              0 -> finaliseStreamEnd chunk' zstate\n                                              _ -> checkHeaderSplit (S.head chunk') chunk'' zstate\n                               _ -> checkHeader chunk' zstate\n                1 -> return $\n                       DecompressInputRequired $\n                         \\ chunk' ->\n                           case S.length chunk' of\n                               0 -> finaliseStreamEnd chunk zstate\n                               _ -> checkHeaderSplit (S.head chunk) chunk' zstate\n                _ -> checkHeader chunk zstate\n        \n        checkHeaderSplit ::\n                         Word8 ->\n                           S.ByteString -> Stream.State RealWorld -> IO (DecompressStream IO)\n        checkHeaderSplit 31 chunk zstate\n          | S.head chunk == 139 =\n            do let resume\n                     = decompressStream format params True (S.pack [31, 139])\n               if S.length chunk > 1 then\n                 do (DecompressInputRequired next, zstate') <- runStreamIO resume\n                                                                 zstate\n                    (strm', zstate'') <- runStreamIO (next (S.tail chunk)) zstate'\n                    go strm' zstate'' False\n                 else\n                 do (strm, zstate') <- runStreamIO resume zstate\n                    go strm zstate' False\n        checkHeaderSplit byte chunk zstate\n          = finaliseStreamEnd (S.cons byte chunk) zstate\n        \n        checkHeader ::\n                    S.ByteString -> Stream.State RealWorld -> IO (DecompressStream IO)\n        checkHeader chunk zstate\n          | S.index chunk 0 == 31, S.index chunk 1 == 139 =\n            do let resume = decompressStream format params True chunk\n               (strm', zstate') <- runStreamIO resume zstate\n               go strm' zstate' False\n        checkHeader chunk zstate = finaliseStreamEnd chunk zstate\n        finaliseStreamEnd unconsumed zstate\n          = do _ <- runStreamIO Stream.finalise zstate\n               return (DecompressStreamEnd unconsumed)\n        finaliseStreamError err zstate\n          = do _ <- runStreamIO Stream.finalise zstate\n               return (DecompressStreamError err)"],"instances":[],"language":{"extensions":["RankNTypes","DeriveDataTypeable","BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}