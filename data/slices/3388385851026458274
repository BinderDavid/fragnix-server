{"sliceID":3388385851026458274,"uses":[{"reference":{"otherSlice":5353085893229343222},"usedName":{"constructorName":{"identifier":"PriorityTree"},"constructorTypeName":{"identifier":"PriorityTree"}},"qualification":null},{"reference":{"otherSlice":100452691171660451},"usedName":{"valueName":{"identifier":"dequeue"}},"qualification":"Q"},{"reference":{"otherSlice":5783778720325805178},"usedName":{"constructorName":{"identifier":"Child"},"constructorTypeName":{"identifier":"Element"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$!"}},"qualification":null},{"reference":{"otherSlice":5783778720325805178},"usedName":{"constructorName":{"identifier":"Parent"},"constructorTypeName":{"identifier":"Element"}},"qualification":null},{"reference":{"otherSlice":7381214382763621096},"usedName":{"valueName":{"identifier":"isEmpty"}},"qualification":"Q"},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"unless"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":3797314449682470499},"usedName":{"valueName":{"identifier":"enqueue"}},"qualification":"Q"},{"reference":{"otherSlice":5353085893229343222},"usedName":{"typeName":{"identifier":"PriorityTree"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"typeName":{"identifier":"STM"}},"qualification":null},{"reference":{"otherSlice":606063981647933956},"usedName":{"typeName":{"identifier":"StreamId"}},"qualification":null},{"reference":{"otherSlice":1474726555369894793},"usedName":{"typeName":{"identifier":"Precedence"}},"qualification":null}],"fragment":["dequeueSTM :: PriorityTree a -> STM (StreamId, Precedence, a)","dequeueSTM (PriorityTree _ q0) = loop q0\n  where loop q\n          = do (sid, p, el) <- Q.dequeue q\n               case el of\n                   Child x -> return $! (sid, p, x)\n                   Parent q' -> do entr <- loop q'\n                                   empty <- Q.isEmpty q'\n                                   unless empty $ Q.enqueue q sid p el\n                                   return entr"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}