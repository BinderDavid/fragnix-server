{"sliceID":1123938671127679969,"uses":[{"reference":{"otherSlice":4158094470745031454},"usedName":{"valueName":{"identifier":"reifyConTys"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"otherSlice":2472949373024698355},"usedName":{"valueName":{"identifier":"newNameList"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"zip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":2731042449908740740},"usedName":{"valueName":{"identifier":"emptyArray_"}},"qualification":"E"},{"reference":{"otherSlice":4735960143663518883},"usedName":{"valueName":{"identifier":"dispatchToEncoding"}},"qualification":null},{"reference":{"otherSlice":2999840968035654076},"usedName":{"valueName":{"identifier":"array"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"foldr1"}},"qualification":null},{"reference":{"otherSlice":5903116316445630912},"usedName":{"valueName":{"operator":"<%>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":6411985416072958886},"usedName":{"valueName":{"identifier":"sumToEncoding"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"otherSlice":7721714347464982760},"usedName":{"valueName":{"identifier":"unwrapUnaryRecords"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":5241165181606382074},"usedName":{"valueName":{"identifier":"object"}},"qualification":null},{"reference":{"otherSlice":4693941012606838655},"usedName":{"valueName":{"identifier":"econcat"}},"qualification":"E"},{"reference":{"builtinModule":"Data.List"},"usedName":{"valueName":{"identifier":"intersperse"}},"qualification":null},{"reference":{"otherSlice":2699211246990115058},"usedName":{"valueName":{"identifier":"comma"}},"qualification":"E"},{"reference":{"otherSlice":7721714347464982760},"usedName":{"valueName":{"identifier":"omitNothingFields"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"zip3"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"catMaybes"}},"qualification":null},{"reference":{"builtinModule":"Data.List"},"usedName":{"valueName":{"identifier":"partition"}},"qualification":null},{"reference":{"otherSlice":1421314977802327516},"usedName":{"valueName":{"identifier":"isMaybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":763545479781294654},"usedName":{"valueName":{"operator":"<^>"}},"qualification":null},{"reference":{"otherSlice":2699211246990115058},"usedName":{"valueName":{"identifier":"colon"}},"qualification":"E"},{"reference":{"otherSlice":1953295503533525926},"usedName":{"valueName":{"operator":"><"}},"qualification":"E"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":37739276968098242},"usedName":{"valueName":{"operator":"<:>"}},"qualification":null},{"reference":{"otherSlice":2241240114275565033},"usedName":{"valueName":{"identifier":"text"}},"qualification":"E"},{"reference":{"otherSlice":1239263014128492149},"usedName":{"valueName":{"identifier":"pack"}},"qualification":"T"},{"reference":{"otherSlice":3629971234795832143},"usedName":{"valueName":{"identifier":"fieldLabelExp"}},"qualification":null},{"reference":{"otherSlice":7721714347464982760},"usedName":{"valueName":{"identifier":"sumEncoding"}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"constructorName":{"identifier":"TwoElemArray"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":3260348104434909594},"usedName":{"valueName":{"identifier":"encStr"}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"constructorName":{"identifier":"TaggedObject"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"valueName":{"identifier":"tagFieldName"}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"constructorName":{"identifier":"ObjectWithSingleField"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"constructorName":{"identifier":"UntaggedValue"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"head"}},"qualification":null},{"reference":{"otherSlice":3720735402915720453},"usedName":{"typeName":{"identifier":"JSONClass"}},"qualification":null},{"reference":{"otherSlice":7721714347464982760},"usedName":{"typeName":{"identifier":"Options"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null}],"fragment":["argsToEncoding ::\n               JSONClass -> [(Name, Name)] -> Options -> Bool -> Con -> Q Match","argsToEncoding jc tes opts multiCons (NormalC conName ts)\n  = do (argTys, tvMap) <- reifyConTys jc tes conName\n       let len = length ts\n       args <- newNameList \"arg\" len\n       js <- case zip args argTys of\n                 [] -> return [| E.emptyArray_ |]\n                 [(e, eTy)] -> return\n                                 (dispatchToEncoding jc conName tvMap eTy `appE` varE e)\n                 es -> return\n                         (array\n                            (foldr1 (<%>)\n                               [dispatchToEncoding jc conName tvMap xTy `appE` varE x |\n                                (x, xTy) <- es]))\n       match (conP conName $ map varP args)\n         (normalB $ sumToEncoding opts multiCons (null ts) conName js)\n         []\nargsToEncoding jc tes opts multiCons (RecC conName ts)\n  = case (unwrapUnaryRecords opts, not multiCons, ts) of\n        (True, True, [(_, st, ty)]) -> argsToEncoding jc tes opts multiCons\n                                         (NormalC conName [(st, ty)])\n        _ -> do args <- newNameList \"arg\" $ length ts\n                (argTys, tvMap) <- reifyConTys jc tes conName\n                let exp = object objBody\n                    objBody\n                      = [| E.econcat |] `appE` ([| intersperse E.comma |] `appE` pairs)\n                    pairs\n                      | omitNothingFields opts =\n                        infixApp maybeFields [| (++) |] restFields\n                      | otherwise = listE (map toPair argCons)\n                    argCons = zip3 args argTys ts\n                    maybeFields = [| catMaybes |] `appE` listE (map maybeToPair maybes)\n                    restFields = listE (map toPair rest)\n                    (maybes, rest) = partition isMaybe argCons\n                    maybeToPair (arg, argTy, (field, _, _))\n                      = infixApp\n                          (infixApp\n                             (infixE (Just $ toFieldName field <^> [| E.colon |]) [| (E.><) |]\n                                Nothing)\n                             [| (.) |]\n                             (dispatchToEncoding jc conName tvMap argTy))\n                          [| (<$>) |]\n                          (varE arg)\n                    toPair (arg, argTy, (field, _, _))\n                      = toFieldName field <:>\n                          dispatchToEncoding jc conName tvMap argTy `appE` varE arg\n                    toFieldName field\n                      = [| E.text |] `appE`\n                          ([| T.pack |] `appE` fieldLabelExp opts field)\n                match (conP conName $ map varP args)\n                  (normalB $\n                     if multiCons then\n                       case sumEncoding opts of\n                           TwoElemArray -> array $ encStr opts conName <%> exp\n                           TaggedObject{tagFieldName} -> object $\n                                                           ([| E.text (T.pack tagFieldName) |] <:>\n                                                              encStr opts conName)\n                                                             <%> objBody\n                           ObjectWithSingleField -> object $ encStr opts conName <:> exp\n                           UntaggedValue -> exp\n                       else exp)\n                  []\nargsToEncoding jc tes opts multiCons (InfixC _ conName _)\n  = do al <- newName \"argL\"\n       ar <- newName \"argR\"\n       ([alTy, arTy], tvMap) <- reifyConTys jc tes conName\n       match (infixP (varP al) conName (varP ar))\n         (normalB $\n            sumToEncoding opts multiCons False conName $\n              array\n                (foldr1 (<%>)\n                   [dispatchToEncoding jc conName tvMap aTy `appE` varE a |\n                    (a, aTy) <- [(al, alTy), (ar, arTy)]]))\n         []\nargsToEncoding jc tes opts multiCons (ForallC _ _ con)\n  = argsToEncoding jc tes opts multiCons con\nargsToEncoding jc tes opts multiCons (GadtC conNames ts _)\n  = argsToEncoding jc tes opts multiCons $ NormalC (head conNames) ts\nargsToEncoding jc tes opts multiCons (RecGadtC conNames ts _)\n  = argsToEncoding jc tes opts multiCons $ RecC (head conNames) ts"],"instances":[],"language":{"extensions":["BangPatterns","FlexibleInstances","NamedFieldPuns","NoImplicitPrelude","UndecidableInstances","TemplateHaskellQuotes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards","TemplateHaskell"]}}