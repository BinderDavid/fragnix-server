{"sliceID":6166620187559862752,"uses":[{"reference":{"otherSlice":2655786183038399924},"usedName":{"constructorName":{"identifier":"EncodeStrategy"},"constructorTypeName":{"identifier":"EncodeStrategy"}},"qualification":null},{"reference":{"otherSlice":2655786183038399924},"usedName":{"valueName":{"identifier":"compressionAlgo"}},"qualification":null},{"reference":{"otherSlice":2655786183038399924},"usedName":{"valueName":{"identifier":"useHuffman"}},"qualification":null},{"reference":{"otherSlice":9133174131371776056},"usedName":{"valueName":{"identifier":"newWorkingBuffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":5259961465692531558},"usedName":{"valueName":{"identifier":"changeTableSize"}},"qualification":null},{"reference":{"otherSlice":8036376319176671572},"usedName":{"valueName":{"identifier":"indexedHeaderField"}},"qualification":null},{"reference":{"otherSlice":102579513409195309},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithIncrementalIndexingIndexedName"}},"qualification":null},{"reference":{"otherSlice":6200036698907584902},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithIncrementalIndexingNewName"}},"qualification":null},{"reference":{"otherSlice":3093701897916284817},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithoutIndexingIndexedName"}},"qualification":null},{"reference":{"otherSlice":5676246967161236868},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithoutIndexingNewName"}},"qualification":null},{"reference":{"otherSlice":2959903016418828561},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithoutIndexingNewName'"}},"qualification":null},{"reference":{"otherSlice":991166700563532451},"usedName":{"valueName":{"identifier":"getRevIndex"}},"qualification":null},{"reference":{"otherSlice":6506486142096081718},"usedName":{"constructorName":{"identifier":"Naive"},"constructorTypeName":{"identifier":"CompressionAlgo"}},"qualification":null},{"reference":{"otherSlice":7972971564983662795},"usedName":{"valueName":{"identifier":"naiveStep"}},"qualification":null},{"reference":{"otherSlice":6506486142096081718},"usedName":{"constructorName":{"identifier":"Static"},"constructorTypeName":{"identifier":"CompressionAlgo"}},"qualification":null},{"reference":{"otherSlice":4848657782195720785},"usedName":{"valueName":{"identifier":"staticStep"}},"qualification":null},{"reference":{"otherSlice":6506486142096081718},"usedName":{"constructorName":{"identifier":"Linear"},"constructorTypeName":{"identifier":"CompressionAlgo"}},"qualification":null},{"reference":{"otherSlice":4153643970831852774},"usedName":{"valueName":{"identifier":"linearStep"}},"qualification":null},{"reference":{"otherSlice":5133881241908372099},"usedName":{"valueName":{"identifier":"currentOffset"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"newIORef"}},"qualification":null},{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"catch"}},"qualification":"E"},{"reference":{"otherSlice":958118617932303493},"usedName":{"constructorName":{"identifier":"BufferOverrun"},"constructorTypeName":{"identifier":"BufferOverrun"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"minusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"otherSlice":4643372000236824299},"usedName":{"typeName":{"identifier":"Buffer"}},"qualification":null},{"reference":{"otherSlice":6604573367381828668},"usedName":{"typeName":{"identifier":"BufferSize"}},"qualification":null},{"reference":{"otherSlice":2655786183038399924},"usedName":{"typeName":{"identifier":"EncodeStrategy"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":2728446607831036551},"usedName":{"typeName":{"identifier":"DynamicTable"}},"qualification":null},{"reference":{"otherSlice":1967376015967899813},"usedName":{"typeName":{"identifier":"TokenHeaderList"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null}],"fragment":["encodeTokenHeader ::\n                  Buffer ->\n                    BufferSize ->\n                      EncodeStrategy ->\n                        Bool ->\n                          DynamicTable -> TokenHeaderList -> IO (TokenHeaderList, Int)","encodeTokenHeader buf siz EncodeStrategy{..} first dyntbl hs0\n  = do wbuf <- newWorkingBuffer buf siz\n       when first $ changeTableSize dyntbl wbuf\n       let fa = indexedHeaderField dyntbl wbuf useHuffman\n           fb\n             = literalHeaderFieldWithIncrementalIndexingIndexedName dyntbl wbuf\n                 useHuffman\n           fc\n             = literalHeaderFieldWithIncrementalIndexingNewName dyntbl wbuf\n                 useHuffman\n           fd\n             = literalHeaderFieldWithoutIndexingIndexedName dyntbl wbuf\n                 useHuffman\n           fe\n             = literalHeaderFieldWithoutIndexingNewName dyntbl wbuf useHuffman\n           fe'\n             = literalHeaderFieldWithoutIndexingNewName' dyntbl wbuf useHuffman\n           rev = getRevIndex dyntbl\n           step0\n             = case compressionAlgo of\n                   Naive -> naiveStep fe'\n                   Static -> staticStep fa fd fe\n                   Linear -> linearStep rev fa fb fc fd\n       ref1 <- currentOffset wbuf >>= newIORef\n       ref2 <- newIORef hs0\n       loop wbuf ref1 ref2 step0 hs0 `E.catch`\n         \\ BufferOverrun -> return ()\n       end <- readIORef ref1\n       let !len = end `minusPtr` buf\n       hs <- readIORef ref2\n       return (hs, len)\n  where loop wbuf ref1 ref2 step hsx = go hsx\n          where go [] = return ()\n                go ((t, v) : hs)\n                  = do _ <- step t v\n                       currentOffset wbuf >>= writeIORef ref1\n                       writeIORef ref2 hs\n                       go hs"],"instances":[],"language":{"extensions":["BangPatterns","RecordWildCards","OverloadedStrings","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}