{"sliceID":1200961248750848826,"uses":[{"reference":{"otherSlice":976628837217299383},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":1258919833507916442},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":1258919833507916442},"usedName":{"constructorName":{"identifier":"Skip"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"otherSlice":1258919833507916442},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Monad"}},"qualification":null},{"reference":{"otherSlice":976628837217299383},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null}],"fragment":["(++) :: Monad m => Stream m a -> Stream m a -> Stream m a","Stream stepa ta ++ Stream stepb tb = Stream step (Left ta)\n  where {-# INLINE [0] step #-}\n        step (Left sa)\n          = do r <- stepa sa\n               case r of\n                   Yield x sa' -> return $ Yield x (Left sa')\n                   Skip sa' -> return $ Skip (Left sa')\n                   Done -> return $ Skip (Right tb)\n        step (Right sb)\n          = do r <- stepb sb\n               case r of\n                   Yield x sb' -> return $ Yield x (Right sb')\n                   Skip sb' -> return $ Skip (Right sb')\n                   Done -> return $ Done","infixr 5 ++"],"instances":[],"language":{"extensions":["ExistentialQuantification","MultiParamTypeClasses","FlexibleInstances","Rank2Types","BangPatterns","KindSignatures","GADTs","ScopedTypeVariables","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}