{"sliceID":7572939698119582666,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"typeName":{"identifier":"Eq"}},"qualification":null},{"reference":{"otherSlice":6947997737051125680},"usedName":{"typeName":{"identifier":"Hashable"}},"qualification":null},{"reference":{"otherSlice":4871054613251541877},"usedName":{"typeName":{"identifier":"HashMap"}},"qualification":null},{"reference":{"otherSlice":4871054613251541877},"usedName":{"constructorName":{"identifier":"Empty"},"constructorTypeName":{"identifier":"HashMap"}},"qualification":null},{"reference":{"otherSlice":4871054613251541877},"usedName":{"constructorName":{"identifier":"Leaf"},"constructorTypeName":{"identifier":"HashMap"}},"qualification":null},{"reference":{"otherSlice":3998322101007631306},"usedName":{"constructorName":{"identifier":"L"},"constructorTypeName":{"identifier":"Leaf"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":6325252103272764254},"usedName":{"valueName":{"identifier":"leaf"}},"qualification":null},{"reference":{"otherSlice":4529322583985048063},"usedName":{"valueName":{"identifier":"collision"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":4871054613251541877},"usedName":{"constructorName":{"identifier":"Collision"},"constructorTypeName":{"identifier":"HashMap"}},"qualification":null},{"reference":{"otherSlice":7054736051932461669},"usedName":{"valueName":{"identifier":"updateOrSnocWithKey"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"flip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":7926578881220185078},"usedName":{"valueName":{"identifier":"updateOrConcatWithKey"}},"qualification":null},{"reference":{"otherSlice":4871054613251541877},"usedName":{"constructorName":{"identifier":"BitmapIndexed"},"constructorTypeName":{"identifier":"HashMap"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".|."}},"qualification":null},{"reference":{"otherSlice":1637803239913441460},"usedName":{"valueName":{"identifier":"unionArrayBy"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":2031517040786215680},"usedName":{"valueName":{"identifier":"bitsPerSubkey"}},"qualification":null},{"reference":{"otherSlice":258169505551792130},"usedName":{"valueName":{"identifier":"bitmapIndexedOrFull"}},"qualification":null},{"reference":{"otherSlice":4871054613251541877},"usedName":{"constructorName":{"identifier":"Full"},"constructorTypeName":{"identifier":"HashMap"}},"qualification":null},{"reference":{"otherSlice":1936919481856046494},"usedName":{"valueName":{"identifier":"fullNodeMask"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".&."}},"qualification":null},{"reference":{"otherSlice":6724174691851673434},"usedName":{"valueName":{"identifier":"insert"}},"qualification":"A"},{"reference":{"otherSlice":8257086387474121113},"usedName":{"valueName":{"identifier":"updateWith'"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":8692377828033704741},"usedName":{"valueName":{"identifier":"mask"}},"qualification":null},{"reference":{"otherSlice":3162727719459805984},"usedName":{"valueName":{"identifier":"sparseIndex"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$!"}},"qualification":null},{"reference":{"otherSlice":6264238055823815301},"usedName":{"valueName":{"identifier":"index"}},"qualification":null},{"reference":{"otherSlice":3258904793973172673},"usedName":{"valueName":{"identifier":"update16With'"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"otherSlice":4486064531931808434},"usedName":{"valueName":{"identifier":"singleton"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":8623158130248303345},"usedName":{"valueName":{"identifier":"pair"}},"qualification":"A"}],"fragment":["unionWithKey ::\n               (Eq k, Hashable k) =>\n               (k -> v -> v -> v) -> HashMap k v -> HashMap k v -> HashMap k v","unionWithKey f = go 0\n  where go !_ t1 Empty = t1\n        go _ Empty t2 = t2\n        go s t1@(Leaf h1 l1@(L k1 v1)) t2@(Leaf h2 l2@(L k2 v2))\n          | h1 == h2 =\n            if k1 == k2 then leaf h1 k1 (f k1 v1 v2) else collision h1 l1 l2\n          | otherwise = goDifferentHash s h1 h2 t1 t2\n        go s t1@(Leaf h1 (L k1 v1)) t2@(Collision h2 ls2)\n          | h1 == h2 = Collision h1 (updateOrSnocWithKey f k1 v1 ls2)\n          | otherwise = goDifferentHash s h1 h2 t1 t2\n        go s t1@(Collision h1 ls1) t2@(Leaf h2 (L k2 v2))\n          | h1 == h2 =\n            Collision h1 (updateOrSnocWithKey (flip . f) k2 v2 ls1)\n          | otherwise = goDifferentHash s h1 h2 t1 t2\n        go s t1@(Collision h1 ls1) t2@(Collision h2 ls2)\n          | h1 == h2 = Collision h1 (updateOrConcatWithKey f ls1 ls2)\n          | otherwise = goDifferentHash s h1 h2 t1 t2\n        go s (BitmapIndexed b1 ary1) (BitmapIndexed b2 ary2)\n          = let b' = b1 .|. b2\n                ary' = unionArrayBy (go (s + bitsPerSubkey)) b1 b2 ary1 ary2\n              in bitmapIndexedOrFull b' ary'\n        go s (BitmapIndexed b1 ary1) (Full ary2)\n          = let ary'\n                  = unionArrayBy (go (s + bitsPerSubkey)) b1 fullNodeMask ary1 ary2\n              in Full ary'\n        go s (Full ary1) (BitmapIndexed b2 ary2)\n          = let ary'\n                  = unionArrayBy (go (s + bitsPerSubkey)) fullNodeMask b2 ary1 ary2\n              in Full ary'\n        go s (Full ary1) (Full ary2)\n          = let ary'\n                  = unionArrayBy (go (s + bitsPerSubkey)) fullNodeMask fullNodeMask\n                      ary1\n                      ary2\n              in Full ary'\n        go s (BitmapIndexed b1 ary1) t2\n          | b1 .&. m2 == 0 =\n            let ary' = A.insert ary1 i t2\n                b' = b1 .|. m2\n              in bitmapIndexedOrFull b' ary'\n          | otherwise =\n            let ary'\n                  = A.updateWith' ary1 i $ \\ st1 -> go (s + bitsPerSubkey) st1 t2\n              in BitmapIndexed b1 ary'\n          where h2 = leafHashCode t2\n                m2 = mask h2 s\n                i = sparseIndex b1 m2\n        go s t1 (BitmapIndexed b2 ary2)\n          | b2 .&. m1 == 0 =\n            let ary' = A.insert ary2 i $! t1\n                b' = b2 .|. m1\n              in bitmapIndexedOrFull b' ary'\n          | otherwise =\n            let ary'\n                  = A.updateWith' ary2 i $ \\ st2 -> go (s + bitsPerSubkey) t1 st2\n              in BitmapIndexed b2 ary'\n          where h1 = leafHashCode t1\n                m1 = mask h1 s\n                i = sparseIndex b2 m1\n        go s (Full ary1) t2\n          = let h2 = leafHashCode t2\n                i = index h2 s\n                ary'\n                  = update16With' ary1 i $ \\ st1 -> go (s + bitsPerSubkey) st1 t2\n              in Full ary'\n        go s t1 (Full ary2)\n          = let h1 = leafHashCode t1\n                i = index h1 s\n                ary'\n                  = update16With' ary2 i $ \\ st2 -> go (s + bitsPerSubkey) t1 st2\n              in Full ary'\n        leafHashCode (Leaf h _) = h\n        leafHashCode (Collision h _) = h\n        leafHashCode _ = error \"leafHashCode\"\n        goDifferentHash s h1 h2 t1 t2\n          | m1 == m2 =\n            BitmapIndexed m1 (A.singleton $! go (s + bitsPerSubkey) t1 t2)\n          | m1 < m2 = BitmapIndexed (m1 .|. m2) (A.pair t1 t2)\n          | otherwise = BitmapIndexed (m1 .|. m2) (A.pair t2 t1)\n          where m1 = mask h1 s\n                m2 = mask h2 s"],"instances":[],"language":{"extensions":["BangPatterns","PatternGuards","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"]}}