{"sliceID":3870078632228993925,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"identifier":"satisfy"}},"qualification":"ReadP"},{"reference":{"otherSlice":6432786935922988421},"usedName":{"valueName":{"identifier":"isSign"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"mplus"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"typeName":{"identifier":"Num"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":1361789892864475703},"usedName":{"valueName":{"identifier":"foldDigits"}},"qualification":null},{"reference":{"otherSlice":4108651305018319501},"usedName":{"constructorName":{"identifier":"SP"},"constructorTypeName":{"identifier":"SP"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"operator":"<++"}},"qualification":"ReadP"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":5714725324496896541},"usedName":{"valueName":{"identifier":"isE"}},"qualification":null},{"reference":{"otherSlice":1008626907939011545},"usedName":{"constructorName":{"identifier":"Scientific"},"constructorTypeName":{"identifier":"Scientific"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"typeName":{"identifier":"ReadP"}},"qualification":null},{"reference":{"otherSlice":1008626907939011545},"usedName":{"typeName":{"identifier":"Scientific"}},"qualification":null}],"fragment":["scientificP :: ReadP Scientific","scientificP\n  = do let positive\n             = (('+' ==) <$> ReadP.satisfy isSign) `mplus` return True\n       pos <- positive\n       let step :: Num a => a -> Int -> a\n           step a digit = a * 10 + fromIntegral digit\n           {-# INLINE step #-}\n       n <- foldDigits step 0\n       let s = SP n 0\n           fractional\n             = foldDigits (\\ (SP a e) digit -> SP (step a digit) (e - 1)) s\n       SP coeff expnt <- (ReadP.satisfy (== '.') >> fractional) ReadP.<++\n                           return s\n       let signedCoeff\n             | pos = coeff\n             | otherwise = (-coeff)\n           eP\n             = do posE <- positive\n                  e <- foldDigits step 0\n                  if posE then return e else return (-e)\n       (ReadP.satisfy isE >>\n          ((Scientific signedCoeff . (expnt +)) <$> eP))\n         `mplus` return (Scientific signedCoeff expnt)"],"instances":[],"language":{"extensions":["DeriveDataTypeable","BangPatterns","ScopedTypeVariables","UnboxedTuples","PatternGuards","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"]}}