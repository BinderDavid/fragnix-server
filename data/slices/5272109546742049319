{"sliceID":5272109546742049319,"uses":[{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"minimum"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":8819855837653387286},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"quot"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"builtinModule":"GHC.Arr"},"usedName":{"valueName":{"identifier":"listArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"otherSlice":8499745574635551934},"usedName":{"valueName":{"identifier":"rehash1"}},"qualification":null},{"reference":{"otherSlice":1777456677057634181},"usedName":{"valueName":{"identifier":"rehash2"}},"qualification":null},{"reference":{"otherSlice":2433531944639182000},"usedName":{"valueName":{"identifier":"rehash3"}},"qualification":null},{"reference":{"otherSlice":7358526986585398087},"usedName":{"valueName":{"identifier":"rehash4"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":1661752722654164929},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"shiftL"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":1264447719843148261},"usedName":{"valueName":{"identifier":"take"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":null},{"reference":{"otherSlice":5707707704119147439},"usedName":{"valueName":{"identifier":"insertWith"}},"qualification":"IM"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"flip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"otherSlice":7359709951508731186},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"IM"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"zip"}},"qualification":null},{"reference":{"otherSlice":8068578393031383548},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"otherSlice":6396109612671124023},"usedName":{"valueName":{"identifier":"lookup"}},"qualification":"IM"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":1986893899592906745},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"otherSlice":404915850270007730},"usedName":{"valueName":{"identifier":"isPrefixOf"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"filter"}},"qualification":null},{"reference":{"otherSlice":7390130272431652744},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null}],"fragment":["strictMatcher :: [S.ByteString] -> S.ByteString -> [(Int, [Int])]","strictMatcher pats = search\n  where !hLen = minimum (32 : map S.length pats)\n        !shDi\n          = case 32 `quot` hLen of\n                q | q < 4 -> q\n                  | otherwise -> 4\n        !outS = shDi * hLen\n        !patNum = length pats\n        !patArr = listArray (0, patNum - 1) pats\n        \n        {-# INLINE rehash #-}\n        \n        rehash :: Int -> Word8 -> Word8 -> Int\n        rehash\n          = case shDi of\n                1 -> rehash1 hLen\n                2 -> rehash2 outS\n                3 -> rehash3 outS\n                _ -> rehash4 outS\n        \n        hash :: S.ByteString -> Int\n        hash\n          = S.foldl' (\\ h w -> (h `shiftL` shDi) + fromIntegral w) 0 .\n              S.take hLen\n        !hashMap\n          = foldl' (\\ mp (h, i) -> IM.insertWith (flip (++)) h [i] mp)\n              IM.empty\n              $ zip (map hash pats) [0 :: Int ..]\n        search str\n          | strLen < hLen = []\n          | otherwise = go 0 shash\n          where !strLen = S.length str\n                !maxIdx = strLen - hLen\n                \n                {-# INLINE strAt #-}\n                strAt !i = unsafeIndex str i\n                !shash = hash str\n                go !sI !h\n                  = case IM.lookup h hashMap of\n                        Nothing -> if sI == maxIdx then [] else\n                                     go (sI + 1) (rehash h (strAt sI) (strAt (sI + hLen)))\n                        Just ps -> let !rst = S.drop sI str\n                                       \n                                       {-# INLINE hd #-}\n                                       hd = strAt sI\n                                       \n                                       {-# INLINE more #-}\n                                       more\n                                         = if sI == maxIdx then [] else\n                                             go (sI + 1) (rehash h hd (strAt (sI + hLen)))\n                                       \n                                       {-# INLINE okay #-}\n                                       okay bs = S.isPrefixOf bs rst\n                                     in\n                                     case filter (okay . (patArr `unsafeAt`)) ps of\n                                         [] -> more\n                                         qs -> seq (length qs) $ (sI, qs) : more"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}