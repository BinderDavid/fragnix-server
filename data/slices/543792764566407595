{"sliceID":543792764566407595,"uses":[{"reference":{"otherSlice":5578418172209195165},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"enumFromTo"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":8819855837653387286},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":7849470518260417306},"usedName":{"valueName":{"identifier":"head"}},"qualification":"S"},{"reference":{"otherSlice":3614395790875576105},"usedName":{"valueName":{"identifier":"elemIndices"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"otherSlice":8068578393031383548},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"maxBound"}},"qualification":null},{"reference":{"otherSlice":6344115257838258192},"usedName":{"valueName":{"identifier":"occurs"}},"qualification":null},{"reference":{"otherSlice":3089591218391594888},"usedName":{"valueName":{"identifier":"suffShifts"}},"qualification":null},{"reference":{"otherSlice":7390130272431652744},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"max"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"}],"fragment":["strictSearcher :: Bool -> S.ByteString -> S.ByteString -> [Int]","strictSearcher _ !pat\n  | S.null pat = enumFromTo 0 . S.length\n  | S.length pat == 1 = let !w = S.head pat in S.elemIndices w\nstrictSearcher !overlap pat = searcher\n  where {-# INLINE patAt #-}\n        \n        patAt :: Int -> Word8\n        patAt !i = unsafeIndex pat i\n        !patLen = S.length pat\n        !patEnd = patLen - 1\n        !maxLen = maxBound - patLen\n        !occT = occurs pat\n        !suffT = suffShifts pat\n        !skip = if overlap then unsafeAt suffT 0 else patLen\n        !kept = patLen - skip\n        !pe = patAt patEnd\n        \n        {-# INLINE occ #-}\n        occ !w = unsafeAt occT (fromIntegral w)\n        \n        {-# INLINE suff #-}\n        suff !i = unsafeAt suffT i\n        searcher str\n          | maxLen < strLen = error \"Overflow in BoyerMoore.strictSearcher\"\n          | maxDiff < 0 = []\n          | otherwise = checkEnd patEnd\n          where !strLen = S.length str\n                !strEnd = strLen - 1\n                !maxDiff = strLen - patLen\n                \n                {-# INLINE strAt #-}\n                strAt !i = unsafeIndex str i\n                afterMatch !diff !patI\n                  = case strAt (diff + patI) of\n                        !c | c == patAt patI ->\n                             if patI == kept then\n                               diff :\n                                 let !diff' = diff + skip in\n                                   if maxDiff < diff' then [] else afterMatch diff' patEnd\n                               else afterMatch diff (patI - 1)\n                           | patI == patEnd -> checkEnd (diff + 2 * patEnd + occ c)\n                           | otherwise ->\n                             let {-# INLINE badShift #-}\n                                 badShift = patI + occ c\n                                 \n                                 {-# INLINE goodShift #-}\n                                 goodShift = suff patI\n                                 !diff' = diff + max badShift goodShift\n                               in if maxDiff < diff' then [] else checkEnd (diff + patEnd)\n                checkEnd !sI\n                  | strEnd < sI = []\n                  | otherwise =\n                    case strAt sI of\n                        !c | c == pe -> findMatch (sI - patEnd) (patEnd - 1)\n                           | otherwise -> checkEnd (sI + patEnd + occ c)\n                findMatch !diff !patI\n                  = case strAt (diff + patI) of\n                        !c | c == patAt patI ->\n                             if patI == 0 then\n                               diff :\n                                 let !diff' = diff + skip in\n                                   if maxDiff < diff' then [] else\n                                     if skip == patLen then checkEnd (diff' + patEnd) else\n                                       afterMatch diff' patEnd\n                               else findMatch diff (patI - 1)\n                           | otherwise ->\n                             let !diff' = diff + max (patI + occ c) (suff patI) in\n                               if maxDiff < diff' then [] else checkEnd (diff' + patEnd)"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}