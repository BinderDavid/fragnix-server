{"sliceID":4700449487939487972,"uses":[{"reference":{"otherSlice":8026779462087009242},"usedName":{"valueName":{"identifier":"mkSource"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int64"}},"qualification":null},{"reference":{"otherSlice":9208956969054095845},"usedName":{"typeName":{"identifier":"Source"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":5657184471628079556},"usedName":{"valueName":{"identifier":"takeLine"}},"qualification":null},{"reference":{"otherSlice":4915886393898742696},"usedName":{"valueName":{"identifier":"prboMaxHeaderLineLength"}},"qualification":null},{"reference":{"otherSlice":4316035772404235902},"usedName":{"valueName":{"identifier":"takeLines'"}},"qualification":null},{"reference":{"otherSlice":4915886393898742696},"usedName":{"valueName":{"identifier":"prboMaxHeaderLines"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"unless"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"lookup"}},"qualification":null},{"reference":{"otherSlice":6172453257856497827},"usedName":{"valueName":{"identifier":"parseAttrs"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":4915886393898742696},"usedName":{"valueName":{"identifier":"prboKeyLength"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"otherSlice":8819855837653387286},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":4915886393898742696},"usedName":{"valueName":{"identifier":"prboMaxNumFiles"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"fromMaybe"}},"qualification":null},{"reference":{"otherSlice":3173435256708193976},"usedName":{"constructorName":{"identifier":"FileInfo"},"constructorTypeName":{"identifier":"FileInfo"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"catMaybes"}},"qualification":null},{"reference":{"otherSlice":4915886393898742696},"usedName":{"valueName":{"identifier":"prboMaxFileSize"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"identifier":"subtract"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":4915886393898742696},"usedName":{"valueName":{"identifier":"prboMaxFilesSize"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"minimum"}},"qualification":null},{"reference":{"otherSlice":6337096564002068767},"usedName":{"valueName":{"identifier":"sinkTillBound'"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":3173435256708193976},"usedName":{"valueName":{"identifier":"fileContent"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":3803441861707793983},"usedName":{"valueName":{"identifier":"sinkTillBound"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":4915886393898742696},"usedName":{"valueName":{"identifier":"prboMaxParmsSize"}},"qualification":null},{"reference":{"otherSlice":248739104559243974},"usedName":{"valueName":{"identifier":"concat"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":7757403855399631850},"usedName":{"valueName":{"identifier":"mk"}},"qualification":null},{"reference":{"otherSlice":4266482746038848749},"usedName":{"valueName":{"identifier":"pack"}},"qualification":"S8"},{"reference":{"otherSlice":6424585508761827152},"usedName":{"valueName":{"identifier":"breakDiscard"}},"qualification":null},{"reference":{"otherSlice":5030599164842377315},"usedName":{"valueName":{"identifier":"dropWhile"}},"qualification":"S"},{"reference":{"otherSlice":4915886393898742696},"usedName":{"typeName":{"identifier":"ParseRequestBodyOptions"}},"qualification":null},{"reference":{"otherSlice":7789413659326569857},"usedName":{"typeName":{"identifier":"BackEnd"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Either"},"usedName":{"typeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":1156478319431720055},"usedName":{"typeName":{"identifier":"Param"}},"qualification":null},{"reference":{"otherSlice":6377169190689415136},"usedName":{"typeName":{"identifier":"File"}},"qualification":null}],"fragment":["parsePiecesEx ::\n              ParseRequestBodyOptions ->\n                BackEnd y ->\n                  S.ByteString ->\n                    IO S.ByteString -> (Either Param (File y) -> IO ()) -> IO ()","parsePiecesEx o sink bound rbody add\n  = mkSource rbody >>= loop 0 0 0 0\n  where loop :: Int -> Int -> Int -> Int64 -> Source -> IO ()\n        loop numParms numFiles parmSize filesSize src\n          = do _boundLine <- takeLine (prboMaxHeaderLineLength o) src\n               res' <- takeLines' (prboMaxHeaderLineLength o)\n                         (prboMaxHeaderLines o)\n                         src\n               unless (null res') $\n                 do let ls' = map parsePair res'\n                    let x = do cd <- lookup contDisp ls'\n                               let ct = lookup contType ls'\n                               let attrs = parseAttrs cd\n                               name <- lookup \"name\" attrs\n                               return (ct, name, lookup \"filename\" attrs)\n                    case x of\n                        Just (mct, name, Just filename) -> do case prboKeyLength o of\n                                                                  Just maxKeyLength -> when\n                                                                                         (S.length\n                                                                                            name\n                                                                                            >\n                                                                                            maxKeyLength)\n                                                                                         $\n                                                                                         error\n                                                                                           \"Filename is too long\"\n                                                                  Nothing -> return ()\n                                                              case prboMaxNumFiles o of\n                                                                  Just maxFiles -> when\n                                                                                     (numFiles >=\n                                                                                        maxFiles)\n                                                                                     $\n                                                                                     error\n                                                                                       \"Maximum number of files exceeded\"\n                                                                  Nothing -> return ()\n                                                              let ct\n                                                                    = fromMaybe\n                                                                        \"application/octet-stream\"\n                                                                        mct\n                                                                  fi0 = FileInfo filename ct ()\n                                                                  fs\n                                                                    = catMaybes\n                                                                        [prboMaxFileSize o,\n                                                                         subtract filesSize <$>\n                                                                           prboMaxFilesSize o]\n                                                                  mfs\n                                                                    = if fs == [] then Nothing else\n                                                                        Just $ minimum fs\n                                                              ((wasFound, fileSize),\n                                                               y) <- sinkTillBound' bound name fi0\n                                                                       sink\n                                                                       src\n                                                                       mfs\n                                                              let newFilesSize\n                                                                    = filesSize + fileSize\n                                                              add $\n                                                                Right (name, fi0{fileContent = y})\n                                                              when wasFound $\n                                                                loop numParms (numFiles + 1)\n                                                                  parmSize\n                                                                  newFilesSize\n                                                                  src\n                        Just (_ct, name, Nothing) -> do case prboKeyLength o of\n                                                            Just maxKeyLength -> when\n                                                                                   (S.length name >\n                                                                                      maxKeyLength)\n                                                                                   $\n                                                                                   error\n                                                                                     \"Parameter name is too long\"\n                                                            Nothing -> return ()\n                                                        let seed = id\n                                                        let iter front bs = return $ front . (:) bs\n                                                        ((wasFound, _fileSize),\n                                                         front) <- sinkTillBound bound iter seed src\n                                                                     (fromIntegral <$>\n                                                                        prboMaxParmsSize o)\n                                                        let bs = S.concat $ front []\n                                                        let x' = (name, bs)\n                                                        let newParmSize\n                                                              = parmSize + S.length name +\n                                                                  S.length bs\n                                                        case prboMaxParmsSize o of\n                                                            Just maxParmSize -> when\n                                                                                  (newParmSize >\n                                                                                     maxParmSize)\n                                                                                  $\n                                                                                  error\n                                                                                    \"Maximum size of parameters exceeded\"\n                                                            Nothing -> return ()\n                                                        add $ Left x'\n                                                        when wasFound $\n                                                          loop (numParms + 1) numFiles newParmSize\n                                                            filesSize\n                                                            src\n                        _ -> do let seed = ()\n                                    iter () _ = return ()\n                                ((wasFound, _fileSize), ()) <- sinkTillBound bound iter seed src\n                                                                 Nothing\n                                when wasFound $ loop numParms numFiles parmSize filesSize src\n          where contDisp = mk $ S8.pack \"Content-Disposition\"\n                contType = mk $ S8.pack \"Content-Type\"\n                parsePair s\n                  = let (x, y) = breakDiscard 58 s in (mk $ x, S.dropWhile (== 32) y)"],"instances":[],"language":{"extensions":["OverloadedStrings","ExistentialQuantification","PatternGuards","TypeFamilies","RankNTypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"]}}