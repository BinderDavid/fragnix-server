{"sliceID":2325125819179893812,"uses":[{"reference":{"otherSlice":4158094470745031454},"usedName":{"valueName":{"identifier":"reifyConTys"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"otherSlice":2472949373024698355},"usedName":{"valueName":{"identifier":"newNameList"}},"qualification":null},{"reference":{"otherSlice":4735960143663518883},"usedName":{"valueName":{"identifier":"dispatchToJSON"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"zip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":8013849340421230462},"usedName":{"valueName":{"identifier":"unsafeNew"}},"qualification":"VM"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":4833656378719677710},"usedName":{"valueName":{"identifier":"unsafeWrite"}},"qualification":"VM"},{"reference":{"builtinModule":"GHC.Integer.GMP.Internals"},"usedName":{"typeName":{"identifier":"Integer"}},"qualification":null},{"reference":{"otherSlice":2337681378693068080},"usedName":{"constructorName":{"identifier":"Array"},"constructorTypeName":{"identifier":"Value"}},"qualification":null},{"reference":{"otherSlice":479735525071965687},"usedName":{"valueName":{"identifier":"create"}},"qualification":"V"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":8165049965374530248},"usedName":{"valueName":{"identifier":"sumToValue"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"otherSlice":7721714347464982760},"usedName":{"valueName":{"identifier":"unwrapUnaryRecords"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":7205873948198437081},"usedName":{"valueName":{"identifier":"object"}},"qualification":"A"},{"reference":{"otherSlice":7721714347464982760},"usedName":{"valueName":{"identifier":"omitNothingFields"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"zip3"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"catMaybes"}},"qualification":null},{"reference":{"builtinModule":"Data.List"},"usedName":{"valueName":{"identifier":"partition"}},"qualification":null},{"reference":{"otherSlice":1421314977802327516},"usedName":{"valueName":{"identifier":"isMaybe"}},"qualification":null},{"reference":{"otherSlice":1324186664995254734},"usedName":{"valueName":{"identifier":"keyValuePairWith"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":1239263014128492149},"usedName":{"valueName":{"identifier":"pack"}},"qualification":"T"},{"reference":{"otherSlice":3629971234795832143},"usedName":{"valueName":{"identifier":"fieldLabelExp"}},"qualification":null},{"reference":{"otherSlice":7721714347464982760},"usedName":{"valueName":{"identifier":"sumEncoding"}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"constructorName":{"identifier":"TwoElemArray"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":9132014293289863210},"usedName":{"valueName":{"identifier":"toJSON"}},"qualification":null},{"reference":{"otherSlice":3849646064215094801},"usedName":{"valueName":{"identifier":"conStr"}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"constructorName":{"identifier":"TaggedObject"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"valueName":{"identifier":"tagFieldName"}},"qualification":null},{"reference":{"otherSlice":5424858156587540989},"usedName":{"valueName":{"operator":".="}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"constructorName":{"identifier":"ObjectWithSingleField"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":4040321383975595781},"usedName":{"valueName":{"identifier":"conTxt"}},"qualification":null},{"reference":{"otherSlice":5829256881764969316},"usedName":{"constructorName":{"identifier":"UntaggedValue"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"head"}},"qualification":null},{"reference":{"otherSlice":3720735402915720453},"usedName":{"typeName":{"identifier":"JSONClass"}},"qualification":null},{"reference":{"otherSlice":7721714347464982760},"usedName":{"typeName":{"identifier":"Options"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null}],"fragment":["argsToValue ::\n            JSONClass -> [(Name, Name)] -> Options -> Bool -> Con -> Q Match","argsToValue jc tjs opts multiCons (NormalC conName ts)\n  = do (argTys, tvMap) <- reifyConTys jc tjs conName\n       let len = length ts\n       args <- newNameList \"arg\" len\n       js <- case\n               [dispatchToJSON jc conName tvMap argTy `appE` varE arg |\n                (arg, argTy) <- zip args argTys]\n               of\n                 [e] -> return e\n                 es -> do mv <- newName \"mv\"\n                          let newMV\n                                = bindS (varP mv)\n                                    ([| VM.unsafeNew |] `appE` litE (integerL $ fromIntegral len))\n                              stmts\n                                = [noBindS $\n                                     [| VM.unsafeWrite |] `appE` varE mv `appE` litE (integerL ix)\n                                       `appE` e\n                                   | (ix, e) <- zip [(0 :: Integer) ..] es]\n                              ret = noBindS $ [| return |] `appE` varE mv\n                          return $\n                            [| Array |] `appE`\n                              (varE 'V.create `appE` doE (newMV : stmts ++ [ret]))\n       match (conP conName $ map varP args)\n         (normalB $ sumToValue opts multiCons (null ts) conName js)\n         []\nargsToValue jc tjs opts multiCons (RecC conName ts)\n  = case (unwrapUnaryRecords opts, not multiCons, ts) of\n        (True, True, [(_, st, ty)]) -> argsToValue jc tjs opts multiCons\n                                         (NormalC conName [(st, ty)])\n        _ -> do (argTys, tvMap) <- reifyConTys jc tjs conName\n                args <- newNameList \"arg\" $ length ts\n                let exp = [| A.object |] `appE` pairs\n                    pairs\n                      | omitNothingFields opts =\n                        infixApp maybeFields [| (++) |] restFields\n                      | otherwise = listE $ map toPair argCons\n                    argCons = zip3 args argTys ts\n                    maybeFields = [| catMaybes |] `appE` listE (map maybeToPair maybes)\n                    restFields = listE $ map toPair rest\n                    (maybes, rest) = partition isMaybe argCons\n                    maybeToPair (arg, argTy, (field, _, _))\n                      = infixApp\n                          ([| keyValuePairWith |] `appE`\n                             dispatchToJSON jc conName tvMap argTy\n                             `appE` toFieldName field)\n                          [| (<$>) |]\n                          (varE arg)\n                    toPair (arg, argTy, (field, _, _))\n                      = [| keyValuePairWith |] `appE`\n                          dispatchToJSON jc conName tvMap argTy\n                          `appE` toFieldName field\n                          `appE` varE arg\n                    toFieldName field = [| T.pack |] `appE` fieldLabelExp opts field\n                match (conP conName $ map varP args)\n                  (normalB $\n                     if multiCons then\n                       case sumEncoding opts of\n                           TwoElemArray -> [| toJSON |] `appE` tupE [conStr opts conName, exp]\n                           TaggedObject{tagFieldName} -> [| A.object |] `appE`\n                                                           infixApp\n                                                             (infixApp [| T.pack tagFieldName |]\n                                                                [| (.=) |]\n                                                                (conStr opts conName))\n                                                             [| (:) |]\n                                                             pairs\n                           ObjectWithSingleField -> [| A.object |] `appE`\n                                                      listE\n                                                        [infixApp (conTxt opts conName) [| (.=) |]\n                                                           exp]\n                           UntaggedValue -> exp\n                       else exp)\n                  []\nargsToValue jc tjs opts multiCons (InfixC _ conName _)\n  = do ([alTy, arTy], tvMap) <- reifyConTys jc tjs conName\n       al <- newName \"argL\"\n       ar <- newName \"argR\"\n       match (infixP (varP al) conName (varP ar))\n         (normalB $\n            sumToValue opts multiCons False conName $\n              [| toJSON |] `appE`\n                listE\n                  [dispatchToJSON jc conName tvMap aTy `appE` varE a |\n                   (a, aTy) <- [(al, alTy), (ar, arTy)]])\n         []\nargsToValue jc tjs opts multiCons (ForallC _ _ con)\n  = argsToValue jc tjs opts multiCons con\nargsToValue jc tjs opts multiCons (GadtC conNames ts _)\n  = argsToValue jc tjs opts multiCons $ NormalC (head conNames) ts\nargsToValue jc tjs opts multiCons (RecGadtC conNames ts _)\n  = argsToValue jc tjs opts multiCons $ RecC (head conNames) ts"],"instances":[],"language":{"extensions":["BangPatterns","FlexibleInstances","NamedFieldPuns","NoImplicitPrelude","UndecidableInstances","TemplateHaskellQuotes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards","TemplateHaskell"]}}