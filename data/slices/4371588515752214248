{"sliceID":4371588515752214248,"uses":[{"reference":{"otherSlice":4942888801223460576},"usedName":{"constructorName":{"identifier":"PS"},"constructorTypeName":{"identifier":"ByteString"}},"qualification":null},{"reference":{"otherSlice":7535420074696502581},"usedName":{"valueName":{"identifier":"runText"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"Foreign.ForeignPtr"},"usedName":{"valueName":{"identifier":"withForeignPtr"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Marshal.Utils"},"usedName":{"valueName":{"identifier":"with"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Types"},"usedName":{"typeName":{"identifier":"CSize"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":3096508274913409088},"usedName":{"valueName":{"identifier":"c_decode_utf8"}},"qualification":null},{"reference":{"otherSlice":5966208167612816875},"usedName":{"valueName":{"identifier":"maBA"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"peek"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"unsafeSTToIO"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":3439034958307438106},"usedName":{"valueName":{"identifier":"unsafeWrite"}},"qualification":null},{"reference":{"otherSlice":5920019322916033742},"usedName":{"valueName":{"identifier":"safe"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"poke"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"unsafeIOToST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"=<<"}},"qualification":null},{"reference":{"otherSlice":577283740759386957},"usedName":{"valueName":{"identifier":"new"}},"qualification":"A"},{"reference":{"otherSlice":4175491122698643153},"usedName":{"typeName":{"identifier":"OnDecodeError"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null},{"reference":{"otherSlice":6658493354337671128},"usedName":{"typeName":{"identifier":"Text"}},"qualification":null}],"fragment":["decodeUtf8With :: OnDecodeError -> ByteString -> Text","decodeUtf8With onErr (PS fp off len)\n  = runText $\n      \\ done ->\n        do let go dest\n                 = withForeignPtr fp $\n                     \\ ptr ->\n                       with (0 :: CSize) $\n                         \\ destOffPtr ->\n                           do let end = ptr `plusPtr` (off + len)\n                                  loop curPtr\n                                    = do curPtr' <- c_decode_utf8 (A.maBA dest) destOffPtr curPtr\n                                                      end\n                                         if curPtr' == end then\n                                           do n <- peek destOffPtr\n                                              unsafeSTToIO (done dest (fromIntegral n))\n                                           else\n                                           do x <- peek curPtr'\n                                              case onErr desc (Just x) of\n                                                  Nothing -> loop $ curPtr' `plusPtr` 1\n                                                  Just c -> do destOff <- peek destOffPtr\n                                                               w <- unsafeSTToIO $\n                                                                      unsafeWrite dest\n                                                                        (fromIntegral destOff)\n                                                                        (safe c)\n                                                               poke destOffPtr\n                                                                 (destOff + fromIntegral w)\n                                                               loop $ curPtr' `plusPtr` 1\n                              loop (ptr `plusPtr` off)\n           (unsafeIOToST . go) =<< A.new len\n  where desc\n          = \"Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream\""],"instances":[],"language":{"extensions":["BangPatterns","ForeignFunctionInterface","GeneralizedNewtypeDeriving","MagicHash","UnliftedFFITypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}