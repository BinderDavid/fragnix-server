{"sliceID":4690775620939659562,"uses":[{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"newIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":8808512626858359762},"usedName":{"valueName":{"identifier":"unsafeFreezeNonEmptyBuffer"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":2981234607007717022},"usedName":{"valueName":{"identifier":"runBuilder"}},"qualification":null},{"reference":{"otherSlice":226002550077825518},"usedName":{"constructorName":{"identifier":"Buffer"},"constructorTypeName":{"identifier":"Buffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"minusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"otherSlice":7564022038032245664},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Next"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"otherSlice":8797962580514482253},"usedName":{"valueName":{"identifier":"updateEndOfSlice"}},"qualification":null},{"reference":{"otherSlice":4791260247128078865},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"otherSlice":7564022038032245664},"usedName":{"constructorName":{"identifier":"More"},"constructorTypeName":{"identifier":"Next"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"otherSlice":5578418172209195165},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":7564022038032245664},"usedName":{"constructorName":{"identifier":"Chunk"},"constructorTypeName":{"identifier":"Next"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":5333386790722188731},"usedName":{"typeName":{"identifier":"BufferAllocStrategy"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":4300821716957373900},"usedName":{"typeName":{"identifier":"BuilderRecv"}},"qualification":null},{"reference":{"otherSlice":229061519635898799},"usedName":{"typeName":{"identifier":"BuilderFinish"}},"qualification":null}],"fragment":["newByteStringBuilderRecv ::\n                         BufferAllocStrategy -> IO (BuilderRecv, BuilderFinish)","newByteStringBuilderRecv (ioBufInit, nextBuf)\n  = do refBuf <- newIORef ioBufInit\n       return (push refBuf, finish refBuf)\n  where finish refBuf\n          = do ioBuf <- readIORef refBuf\n               buf <- ioBuf\n               return $ unsafeFreezeNonEmptyBuffer buf\n        push refBuf builder\n          = do refWri <- newIORef $ Left $ runBuilder builder\n               return $ popper refBuf refWri\n        popper refBuf refWri\n          = do ioBuf <- readIORef refBuf\n               ebWri <- readIORef refWri\n               case ebWri of\n                   Left bWri -> do !buf@(Buffer _ _ op ope) <- ioBuf\n                                   (bytes, next) <- bWri op (ope `minusPtr` op)\n                                   let op' = op `plusPtr` bytes\n                                   case next of\n                                       Done -> do writeIORef refBuf $\n                                                    return $ updateEndOfSlice buf op'\n                                                  return S.empty\n                                       More minSize bWri' -> do let buf' = updateEndOfSlice buf op'\n                                                                    {-# INLINE cont #-}\n                                                                    cont mbs\n                                                                      = do ioBuf' <- nextBuf minSize\n                                                                                       buf'\n                                                                           writeIORef refBuf ioBuf'\n                                                                           writeIORef refWri $\n                                                                             Left bWri'\n                                                                           case mbs of\n                                                                               Just bs | not $\n                                                                                           S.null bs\n                                                                                         ->\n                                                                                         return bs\n                                                                               _ -> popper refBuf\n                                                                                      refWri\n                                                                cont $\n                                                                  unsafeFreezeNonEmptyBuffer buf'\n                                       Chunk bs bWri' -> do let buf' = updateEndOfSlice buf op'\n                                                            let yieldBS\n                                                                  = do nextBuf 1 buf' >>=\n                                                                         writeIORef refBuf\n                                                                       writeIORef refWri $\n                                                                         Left bWri'\n                                                                       if S.null bs then\n                                                                         popper refBuf refWri else\n                                                                         return bs\n                                                            case unsafeFreezeNonEmptyBuffer buf' of\n                                                                Nothing -> yieldBS\n                                                                Just bs' -> do writeIORef refWri $\n                                                                                 Right yieldBS\n                                                                               return bs'\n                   Right action -> action"],"instances":[],"language":{"extensions":["FlexibleContexts","BangPatterns","RankNTypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}