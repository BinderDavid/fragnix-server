{"sliceID":8710168834087217859,"uses":[{"reference":{"otherSlice":8819855837653387286},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"otherSlice":7238205090002904961},"usedName":{"valueName":{"identifier":"lazyBreak"}},"qualification":null},{"reference":{"otherSlice":8680191706454834021},"usedName":{"valueName":{"identifier":"lsplit"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"}],"fragment":["lazySplitKeepFront ::\n                   S.ByteString -> [S.ByteString] -> [[S.ByteString]]","lazySplitKeepFront pat = splitter'\n  where !patLen = S.length pat\n        breaker = lazyBreak pat\n        splitter' strs\n          = case splitter strs of\n                ([] : rest) -> rest\n                other -> other\n        splitter [] = []\n        splitter strs\n          = case breaker strs of\n                (pre, mtch) -> pre :\n                                 case mtch of\n                                     [] -> []\n                                     _ -> case lsplit patLen mtch of\n                                              (pt, rst) -> if null rst then [pt] else\n                                                             let (h : t) = splitter rst in\n                                                               (pt ++ h) : t"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}