{"sliceID":4245862861074684225,"uses":[{"reference":{"otherSlice":1868711746240202356},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":980406524215254660},"usedName":{"valueName":{"identifier":"isEmpty"}},"qualification":null},{"reference":{"otherSlice":660583772428268831},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"I"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":6985743501285579037},"usedName":{"valueName":{"identifier":"text"}},"qualification":"I"},{"reference":{"otherSlice":207069885339927036},"usedName":{"valueName":{"identifier":"upperBound"}},"qualification":null},{"reference":{"otherSlice":4197925349042282867},"usedName":{"valueName":{"identifier":"larger"}},"qualification":null},{"reference":{"otherSlice":460128399940440},"usedName":{"valueName":{"identifier":"run2"}},"qualification":"A"},{"reference":{"otherSlice":577283740759386957},"usedName":{"valueName":{"identifier":"new"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":5528339794293630653},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":5528339794293630653},"usedName":{"constructorName":{"identifier":"Skip"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"otherSlice":5528339794293630653},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":5928679534711299048},"usedName":{"valueName":{"identifier":"shiftL"}},"qualification":null},{"reference":{"otherSlice":3378149163416592467},"usedName":{"valueName":{"identifier":"copyM"}},"qualification":"A"},{"reference":{"otherSlice":3426116284618420958},"usedName":{"valueName":{"identifier":"ord"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":5928679534711299048},"usedName":{"valueName":{"identifier":"shiftR"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".&."}},"qualification":null},{"reference":{"otherSlice":6376244257574649963},"usedName":{"valueName":{"identifier":"unsafeWrite"}},"qualification":"A"},{"reference":{"otherSlice":1868711746240202356},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Char"}},"qualification":null},{"reference":{"otherSlice":6658493354337671128},"usedName":{"typeName":{"identifier":"Text"}},"qualification":null}],"fragment":["reverse :: Stream Char -> Text","reverse (Stream next s len0)\n  | isEmpty len0 = I.empty\n  | otherwise = I.text arr off' len'\n  where len0' = upperBound 4 (larger len0 4)\n        (arr, (off', len'))\n          = A.run2 (A.new len0' >>= loop s (len0' - 1) len0')\n        loop !s0 !i !len marr\n          = case next s0 of\n                Done -> return (marr, (j, len - j))\n                  where j = i + 1\n                Skip s1 -> loop s1 i len marr\n                Yield x s1 | i < least ->\n                             {-# SCC \"reverse/resize\" #-}\n                               do let newLen = len `shiftL` 1\n                                  marr' <- A.new newLen\n                                  A.copyM marr' (newLen - len) marr 0 len\n                                  write s1 (len + i) newLen marr'\n                           | otherwise -> write s1 i len marr\n                  where n = ord x\n                        least\n                          | n < 65536 = 0\n                          | otherwise = 1\n                        m = n - 65536\n                        lo = fromIntegral $ (m `shiftR` 10) + 55296\n                        hi = fromIntegral $ (m .&. 1023) + 56320\n                        write t j l mar\n                          | n < 65536 =\n                            do A.unsafeWrite mar j (fromIntegral n)\n                               loop t (j - 1) l mar\n                          | otherwise =\n                            do A.unsafeWrite mar (j - 1) lo\n                               A.unsafeWrite mar j hi\n                               loop t (j - 2) l mar"],"instances":[],"language":{"extensions":["BangPatterns","MagicHash","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}