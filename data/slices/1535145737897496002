{"sliceID":1535145737897496002,"uses":[{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"catch"}},"qualification":"E"},{"reference":{"otherSlice":3244558403807755735},"usedName":{"constructorName":{"identifier":"Context"},"constructorTypeName":{"identifier":"Context"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"http2settings"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"streamTable"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"concurrency"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"continued"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"clientStreamId"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"inputQ"}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"valueName":{"identifier":"controlQ"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":209820424723097279},"usedName":{"constructorName":{"identifier":"ConnectionError"},"constructorTypeName":{"identifier":"HTTP2Error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Exception"},"usedName":{"valueName":{"identifier":"fromException"}},"qualification":"E"},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"otherSlice":2010536976482159052},"usedName":{"valueName":{"identifier":"goawayFrame"}},"qualification":null},{"reference":{"otherSlice":7450610694038807841},"usedName":{"valueName":{"identifier":"enqueueControl"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":7606099774008308977},"usedName":{"constructorName":{"identifier":"CGoaway"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":8854238798879676744},"usedName":{"valueName":{"identifier":"resetFrame"}},"qualification":null},{"reference":{"otherSlice":7606099774008308977},"usedName":{"constructorName":{"identifier":"CFrame"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"valueName":{"identifier":"yield"}},"qualification":null},{"reference":{"otherSlice":2601220645498647911},"usedName":{"valueName":{"identifier":"frameHeaderLength"}},"qualification":null},{"reference":{"otherSlice":5578418172209195165},"usedName":{"valueName":{"identifier":"null"}},"qualification":"BS"},{"reference":{"otherSlice":7606099774008308977},"usedName":{"constructorName":{"identifier":"CFinish"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"otherSlice":508715330178112412},"usedName":{"valueName":{"identifier":"decodeFrameHeader"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":7980604682421784157},"usedName":{"constructorName":{"identifier":"FrameHeader"},"constructorTypeName":{"identifier":"FrameHeader"}},"qualification":null},{"reference":{"otherSlice":7980604682421784157},"usedName":{"valueName":{"identifier":"streamId"}},"qualification":null},{"reference":{"otherSlice":3818640718686138584},"usedName":{"valueName":{"identifier":"isResponse"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"&&"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"notElem"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FramePriority"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FrameRSTStream"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FrameWindowUpdate"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"throwIO"}},"qualification":"E"},{"reference":{"otherSlice":4373455107983741140},"usedName":{"constructorName":{"identifier":"ProtocolError"},"constructorTypeName":{"identifier":"ErrorCodeId"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FrameUnknown"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":7980604682421784157},"usedName":{"valueName":{"identifier":"payloadLength"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FramePushPromise"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":5193782172782803132},"usedName":{"valueName":{"identifier":"checkFrameHeader"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":209820424723097279},"usedName":{"constructorName":{"identifier":"StreamError"},"constructorTypeName":{"identifier":"HTTP2Error"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"try"}},"qualification":"E"},{"reference":{"builtinModule":"GHC.Exception"},"usedName":{"valueName":{"identifier":"throw"}},"qualification":"E"},{"reference":{"otherSlice":3723737430146553770},"usedName":{"valueName":{"identifier":"isControl"}},"qualification":null},{"reference":{"otherSlice":1672000087349360585},"usedName":{"valueName":{"identifier":"control"}},"qualification":null},{"reference":{"otherSlice":8563723542902844888},"usedName":{"constructorName":{"identifier":"PriorityFrame"},"constructorTypeName":{"identifier":"FramePayload"}},"qualification":null},{"reference":{"otherSlice":6140162584443591277},"usedName":{"valueName":{"identifier":"guardIt"}},"qualification":null},{"reference":{"otherSlice":2035370252098002591},"usedName":{"valueName":{"identifier":"decodePriorityFrame"}},"qualification":null},{"reference":{"otherSlice":3896349541620594627},"usedName":{"valueName":{"identifier":"checkPriority"}},"qualification":null},{"reference":{"otherSlice":686719806749404538},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":686719806749404538},"usedName":{"valueName":{"identifier":"streamState"}},"qualification":null},{"reference":{"otherSlice":686719806749404538},"usedName":{"valueName":{"identifier":"streamPrecedence"}},"qualification":null},{"reference":{"otherSlice":224558358116176119},"usedName":{"valueName":{"identifier":"stream"}},"qualification":null},{"reference":{"otherSlice":3281083188637845408},"usedName":{"constructorName":{"identifier":"Open"},"constructorTypeName":{"identifier":"StreamState"}},"qualification":null},{"reference":{"otherSlice":6386400259197273904},"usedName":{"constructorName":{"identifier":"NoBody"},"constructorTypeName":{"identifier":"OpenState"}},"qualification":null},{"reference":{"otherSlice":3175645509571572385},"usedName":{"valueName":{"identifier":"readInt"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":1790361685794662609},"usedName":{"valueName":{"identifier":"getHeaderValue"}},"qualification":null},{"reference":{"otherSlice":7844188091538209557},"usedName":{"valueName":{"identifier":"tokenContentLength"}},"qualification":null},{"reference":{"otherSlice":4677170291420271609},"usedName":{"valueName":{"identifier":"just"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"otherSlice":3815283975219979718},"usedName":{"valueName":{"identifier":"toPrecedence"}},"qualification":null},{"reference":{"otherSlice":3281083188637845408},"usedName":{"constructorName":{"identifier":"HalfClosed"},"constructorTypeName":{"identifier":"StreamState"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"valueName":{"identifier":"atomically"}},"qualification":null},{"reference":{"otherSlice":5519274105550261016},"usedName":{"valueName":{"identifier":"writeTQueue"}},"qualification":null},{"reference":{"otherSlice":187204259777281489},"usedName":{"constructorName":{"identifier":"Input"},"constructorTypeName":{"identifier":"Input"}},"qualification":null},{"reference":{"otherSlice":6386400259197273904},"usedName":{"constructorName":{"identifier":"HasBody"},"constructorTypeName":{"identifier":"OpenState"}},"qualification":null},{"reference":{"otherSlice":6297258265142105704},"usedName":{"valueName":{"identifier":"newTQueueIO"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"newIORef"}},"qualification":null},{"reference":{"otherSlice":6386400259197273904},"usedName":{"constructorName":{"identifier":"Body"},"constructorTypeName":{"identifier":"OpenState"}},"qualification":null},{"reference":{"otherSlice":532447941995214531},"usedName":{"valueName":{"identifier":"newReadBody"}},"qualification":null},{"reference":{"otherSlice":8319270568586291478},"usedName":{"valueName":{"identifier":"mkSource"}},"qualification":null},{"reference":{"otherSlice":3073900091224728213},"usedName":{"valueName":{"identifier":"readSource"}},"qualification":null},{"reference":{"otherSlice":6386400259197273904},"usedName":{"constructorName":{"identifier":"Continued"},"constructorTypeName":{"identifier":"OpenState"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FrameContinuation"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":4248176430294945364},"usedName":{"valueName":{"identifier":"search"}},"qualification":null},{"reference":{"otherSlice":8567078786032081139},"usedName":{"constructorName":{"identifier":"FrameHeaders"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":599971767167013435},"usedName":{"valueName":{"identifier":"isHalfClosed"}},"qualification":null},{"reference":{"otherSlice":4373455107983741140},"usedName":{"constructorName":{"identifier":"StreamClosed"},"constructorTypeName":{"identifier":"ErrorCodeId"}},"qualification":null},{"reference":{"otherSlice":991826200323355792},"usedName":{"valueName":{"identifier":"isIdle"}},"qualification":null},{"reference":{"otherSlice":7595571861222973592},"usedName":{"valueName":{"identifier":"opened"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"otherSlice":7372516785893394230},"usedName":{"valueName":{"identifier":"maxConcurrency"}},"qualification":null},{"reference":{"otherSlice":4373455107983741140},"usedName":{"constructorName":{"identifier":"RefusedStream"},"constructorTypeName":{"identifier":"ErrorCodeId"}},"qualification":null},{"reference":{"otherSlice":3267890705975083998},"usedName":{"valueName":{"identifier":"initialWindowSize"}},"qualification":null},{"reference":{"otherSlice":7720354856515006461},"usedName":{"valueName":{"identifier":"newStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":8505976240366668527},"usedName":{"valueName":{"identifier":"insert"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"identifier":"void"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":3244558403807755735},"usedName":{"typeName":{"identifier":"Context"}},"qualification":null},{"reference":{"otherSlice":3541901859045492146},"usedName":{"typeName":{"identifier":"MkReq"}},"qualification":null},{"reference":{"otherSlice":4569852275802132727},"usedName":{"typeName":{"identifier":"BufSize"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null}],"fragment":["frameReceiver ::\n              Context -> MkReq -> (BufSize -> IO ByteString) -> IO ()","frameReceiver ctx mkreq recvN = loop 0 `E.catch` sendGoaway\n  where Context{http2settings, streamTable, concurrency, continued,\n                clientStreamId, inputQ, controlQ}\n          = ctx\n        sendGoaway e\n          | Just (ConnectionError err msg) <- E.fromException e =\n            do csid <- readIORef clientStreamId\n               let !frame = goawayFrame csid err msg\n               enqueueControl controlQ $ CGoaway frame\n          | otherwise = return ()\n        sendReset err sid\n          = do let !frame = resetFrame err sid\n               enqueueControl controlQ $ CFrame frame\n        \n        loop :: Int -> IO ()\n        loop !n\n          | n == 6 =\n            do yield\n               loop 0\n          | otherwise =\n            do hd <- recvN frameHeaderLength\n               if BS.null hd then enqueueControl controlQ CFinish else\n                 do cont <- processStreamGuardingError $ decodeFrameHeader hd\n                    when cont $ loop (n + 1)\n        processStreamGuardingError (fid, FrameHeader{streamId})\n          | isResponse streamId &&\n              (fid `notElem` [FramePriority, FrameRSTStream, FrameWindowUpdate])\n            =\n            E.throwIO $ ConnectionError ProtocolError \"stream id should be odd\"\n        processStreamGuardingError\n          (FrameUnknown _, FrameHeader{payloadLength})\n          = do mx <- readIORef continued\n               case mx of\n                   Nothing -> do consume payloadLength\n                                 return True\n                   Just _ -> E.throwIO $ ConnectionError ProtocolError \"unknown frame\"\n        processStreamGuardingError (FramePushPromise, _)\n          = E.throwIO $\n              ConnectionError ProtocolError \"push promise is not allowed\"\n        processStreamGuardingError\n          typhdr@(ftyp, header@FrameHeader{payloadLength})\n          = do settings <- readIORef http2settings\n               case checkFrameHeader settings typhdr of\n                   Left h2err -> case h2err of\n                                     StreamError err sid -> do sendReset err sid\n                                                               consume payloadLength\n                                                               return True\n                                     connErr -> E.throwIO connErr\n                   Right _ -> do ex <- E.try $ controlOrStream ftyp header\n                                 case ex of\n                                     Left (StreamError err sid) -> do sendReset err sid\n                                                                      return True\n                                     Left connErr -> E.throw connErr\n                                     Right cont -> return cont\n        controlOrStream ftyp header@FrameHeader{streamId, payloadLength}\n          | isControl streamId =\n            do pl <- recvN payloadLength\n               control ftyp header pl ctx\n          | otherwise =\n            do checkContinued\n               !mstrm <- getStream\n               pl <- recvN payloadLength\n               case mstrm of\n                   Nothing -> do when (ftyp == FramePriority) $\n                                   do PriorityFrame newpri <- guardIt $\n                                                                decodePriorityFrame header pl\n                                      checkPriority newpri streamId\n                                 return True\n                   Just\n                     strm@Stream{streamState, streamPrecedence} -> do state <- readIORef\n                                                                                 streamState\n                                                                      state' <- stream ftyp header\n                                                                                  pl\n                                                                                  ctx\n                                                                                  state\n                                                                                  strm\n                                                                      case state' of\n                                                                          Open\n                                                                            (NoBody tbl@(_, reqvt)\n                                                                               pri) -> do resetContinued\n                                                                                          let mcl\n                                                                                                = readInt\n                                                                                                    <$>\n                                                                                                    getHeaderValue\n                                                                                                      tokenContentLength\n                                                                                                      reqvt\n                                                                                          when\n                                                                                            (just\n                                                                                               mcl\n                                                                                               (== (0 ::\n                                                                                                      Int)))\n                                                                                            $\n                                                                                            E.throwIO\n                                                                                              $\n                                                                                              StreamError\n                                                                                                ProtocolError\n                                                                                                streamId\n                                                                                          writeIORef\n                                                                                            streamPrecedence\n                                                                                            $\n                                                                                            toPrecedence\n                                                                                              pri\n                                                                                          writeIORef\n                                                                                            streamState\n                                                                                            HalfClosed\n                                                                                          (!req,\n                                                                                           !ii) <- mkreq\n                                                                                                     tbl\n                                                                                                     (Just\n                                                                                                        0,\n                                                                                                      return\n                                                                                                        \"\")\n                                                                                          atomically\n                                                                                            $\n                                                                                            writeTQueue\n                                                                                              inputQ\n                                                                                              $\n                                                                                              Input\n                                                                                                strm\n                                                                                                req\n                                                                                                reqvt\n                                                                                                ii\n                                                                          Open\n                                                                            (HasBody tbl@(_, reqvt)\n                                                                               pri) -> do resetContinued\n                                                                                          q <- newTQueueIO\n                                                                                          let !mcl\n                                                                                                = readInt\n                                                                                                    <$>\n                                                                                                    getHeaderValue\n                                                                                                      tokenContentLength\n                                                                                                      reqvt\n                                                                                          writeIORef\n                                                                                            streamPrecedence\n                                                                                            $\n                                                                                            toPrecedence\n                                                                                              pri\n                                                                                          bodyLength <- newIORef\n                                                                                                          0\n                                                                                          writeIORef\n                                                                                            streamState\n                                                                                            $\n                                                                                            Open\n                                                                                              (Body\n                                                                                                 q\n                                                                                                 mcl\n                                                                                                 bodyLength)\n                                                                                          readQ <- newReadBody\n                                                                                                     q\n                                                                                          bodySource <- mkSource\n                                                                                                          readQ\n                                                                                          (!req,\n                                                                                           !ii) <- mkreq\n                                                                                                     tbl\n                                                                                                     (mcl,\n                                                                                                      readSource\n                                                                                                        bodySource)\n                                                                                          atomically\n                                                                                            $\n                                                                                            writeTQueue\n                                                                                              inputQ\n                                                                                              $\n                                                                                              Input\n                                                                                                strm\n                                                                                                req\n                                                                                                reqvt\n                                                                                                ii\n                                                                          s@(Open\n                                                                               Continued{}) -> do setContinued\n                                                                                                  writeIORef\n                                                                                                    streamState\n                                                                                                    s\n                                                                          s -> do resetContinued\n                                                                                  writeIORef\n                                                                                    streamState\n                                                                                    s\n                                                                      return True\n          where setContinued = writeIORef continued (Just streamId)\n                resetContinued = writeIORef continued Nothing\n                checkContinued\n                  = do mx <- readIORef continued\n                       case mx of\n                           Nothing -> return ()\n                           Just sid | sid == streamId && ftyp == FrameContinuation ->\n                                      return ()\n                                    | otherwise ->\n                                      E.throwIO $\n                                        ConnectionError ProtocolError\n                                          \"continuation frame must follow\"\n                getStream\n                  = do mstrm0 <- search streamTable streamId\n                       case mstrm0 of\n                           js@(Just strm0) -> do when (ftyp == FrameHeaders) $\n                                                   do st <- readIORef $ streamState strm0\n                                                      when (isHalfClosed st) $\n                                                        E.throwIO $\n                                                          ConnectionError StreamClosed\n                                                            \"header must not be sent to half closed\"\n                                                      when (isIdle st) $ opened ctx strm0\n                                                 return js\n                           Nothing | isResponse streamId -> return Nothing\n                                   | otherwise ->\n                                     do when (ftyp `notElem` [FrameHeaders, FramePriority]) $\n                                          E.throwIO $\n                                            ConnectionError ProtocolError\n                                              \"this frame is not allowed in an idel stream\"\n                                        csid <- readIORef clientStreamId\n                                        if streamId <= csid then\n                                          do if ftyp == FramePriority then return Nothing else\n                                               E.throwIO $\n                                                 ConnectionError ProtocolError\n                                                   \"stream identifier must not decrease\"\n                                          else\n                                          do when (ftyp == FrameHeaders) $\n                                               do writeIORef clientStreamId streamId\n                                                  cnt <- readIORef concurrency\n                                                  when (cnt >= maxConcurrency) $\n                                                    E.throwIO $ StreamError RefusedStream streamId\n                                             ws <- initialWindowSize <$> readIORef http2settings\n                                             newstrm <- newStream streamId (fromIntegral ws)\n                                             when (ftyp == FrameHeaders) $ opened ctx newstrm\n                                             insert streamTable streamId newstrm\n                                             return $ Just newstrm\n        consume = void . recvN"],"instances":[],"language":{"extensions":["OverloadedStrings","NamedFieldPuns","BangPatterns","PatternGuards","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"]}}