{"sliceID":1789625877013388891,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":652411901723476108},"usedName":{"valueName":{"identifier":"char8"}},"qualification":null},{"reference":{"builtinModule":"Data.Monoid"},"usedName":{"valueName":{"operator":"<>"}},"qualification":null},{"reference":{"otherSlice":6526182202285012370},"usedName":{"valueName":{"identifier":"toDecimalDigits"}},"qualification":"Scientific"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":1910684438189978842},"usedName":{"valueName":{"identifier":"i2d"}},"qualification":null},{"reference":{"otherSlice":5676934039154093722},"usedName":{"constructorName":{"identifier":"Generic"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"||"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":5676934039154093722},"usedName":{"constructorName":{"identifier":"Exponent"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"otherSlice":5676934039154093722},"usedName":{"constructorName":{"identifier":"Fixed"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":956356273154969218},"usedName":{"valueName":{"identifier":"intDec"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":61928074876271961},"usedName":{"valueName":{"identifier":"byteStringCopy"}},"qualification":null},{"reference":{"otherSlice":898182340349497864},"usedName":{"valueName":{"identifier":"string8"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"max"}},"qualification":null},{"reference":{"otherSlice":4017226984021812239},"usedName":{"valueName":{"identifier":"replicate"}},"qualification":"BC8"},{"reference":{"otherSlice":8385922469025838797},"usedName":{"valueName":{"identifier":"roundTo"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"init"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"reverse"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"splitAt"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"mempty"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"replicate"}},"qualification":null},{"reference":{"otherSlice":5676934039154093722},"usedName":{"typeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":1008626907939011545},"usedName":{"typeName":{"identifier":"Scientific"}},"qualification":null},{"reference":{"otherSlice":8984783929342293342},"usedName":{"typeName":{"identifier":"Builder"}},"qualification":null}],"fragment":["formatScientificBuilder ::\n                        FPFormat -> Maybe Int -> Scientific -> Builder","formatScientificBuilder fmt decs scntfc\n  | scntfc < 0 =\n    char8 '-' <> doFmt fmt (Scientific.toDecimalDigits (-scntfc))\n  | otherwise = doFmt fmt (Scientific.toDecimalDigits scntfc)\n  where doFmt format (is, e)\n          = let ds = map i2d is in\n              case format of\n                  Generic -> doFmt (if e < 0 || e > 7 then Exponent else Fixed)\n                               (is, e)\n                  Exponent -> case decs of\n                                  Nothing -> let show_e' = intDec (e - 1) in\n                                               case ds of\n                                                   \"0\" -> byteStringCopy \"0.0e0\"\n                                                   [d] -> char8 d <> byteStringCopy \".0e\" <> show_e'\n                                                   (d : ds') -> char8 d <> char8 '.' <> string8 ds'\n                                                                  <> char8 'e'\n                                                                  <> show_e'\n                                                   [] -> error $\n                                                           \"Data.ByteString.Builder.Scientific.formatScientificBuilder\"\n                                                             ++ \"/doFmt/Exponent: []\"\n                                  Just dec -> let dec' = max dec 1 in\n                                                case is of\n                                                    [0] -> byteStringCopy \"0.\" <>\n                                                             byteStringCopy (BC8.replicate dec' '0')\n                                                             <> byteStringCopy \"e0\"\n                                                    _ -> let (ei, is') = roundTo (dec' + 1) is\n                                                             (d : ds')\n                                                               = map i2d\n                                                                   (if ei > 0 then init is' else\n                                                                      is')\n                                                           in\n                                                           char8 d <> char8 '.' <> string8 ds' <>\n                                                             char8 'e'\n                                                             <> intDec (e - 1 + ei)\n                  Fixed -> let mk0 ls\n                                 = case ls of\n                                       \"\" -> char8 '0'\n                                       _ -> string8 ls\n                             in\n                             case decs of\n                                 Nothing | e <= 0 ->\n                                           byteStringCopy \"0.\" <>\n                                             byteStringCopy (BC8.replicate (-e) '0')\n                                             <> string8 ds\n                                         | otherwise ->\n                                           let f 0 s rs = mk0 (reverse s) <> char8 '.' <> mk0 rs\n                                               f n s \"\" = f (n - 1) ('0' : s) \"\"\n                                               f n s (r : rs) = f (n - 1) (r : s) rs\n                                             in f e \"\" ds\n                                 Just dec -> let dec' = max dec 0 in\n                                               if e >= 0 then\n                                                 let (ei, is') = roundTo (dec' + e) is\n                                                     (ls, rs) = splitAt (e + ei) (map i2d is')\n                                                   in\n                                                   mk0 ls <>\n                                                     (if null rs then mempty else\n                                                        char8 '.' <> string8 rs)\n                                                 else\n                                                 let (ei, is')\n                                                       = roundTo dec' (replicate (-e) 0 ++ is)\n                                                     d : ds'\n                                                       = map i2d (if ei > 0 then is' else 0 : is')\n                                                   in\n                                                   char8 d <>\n                                                     (if null ds' then mempty else\n                                                        char8 '.' <> string8 ds')"],"instances":[],"language":{"extensions":["OverloadedStrings","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}