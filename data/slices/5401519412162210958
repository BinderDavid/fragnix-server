{"sliceID":5401519412162210958,"uses":[{"reference":{"otherSlice":4791260247128078865},"usedName":{"valueName":{"identifier":"empty"}},"qualification":null},{"reference":{"otherSlice":3957479230352181842},"usedName":{"valueName":{"identifier":"breakByte"}},"qualification":null},{"reference":{"otherSlice":8204531367323329175},"usedName":{"valueName":{"identifier":"unsafeHead"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"finiteBitSize"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Word"}},"qualification":null},{"reference":{"otherSlice":7409548606206272931},"usedName":{"valueName":{"identifier":"unsafeTake"}},"qualification":null},{"reference":{"otherSlice":3630095162430220529},"usedName":{"valueName":{"identifier":"unsafeDrop"}},"qualification":null},{"reference":{"otherSlice":8819855837653387286},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word32"}},"qualification":null},{"reference":{"otherSlice":1661752722654164929},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"operator":"^"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":8068578393031383548},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"&&"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"shiftL"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".|."}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".&."}},"qualification":null}],"fragment":["breakSubstring ::\n               ByteString -> ByteString -> (ByteString, ByteString)","breakSubstring pat\n  = case lp of\n        0 -> \\ src -> (empty, src)\n        1 -> breakByte (unsafeHead pat)\n        _ -> if lp * 8 <= finiteBitSize (0 :: Word) then shift else\n               karpRabin\n  where unsafeSplitAt i s = (unsafeTake i s, unsafeDrop i s)\n        lp = length pat\n        \n        karpRabin :: ByteString -> (ByteString, ByteString)\n        karpRabin src\n          | length src < lp = (src, empty)\n          | otherwise = search (rollingHash $ unsafeTake lp src) lp\n          where k = 2891336453 :: Word32\n                rollingHash = foldl' (\\ h b -> h * k + fromIntegral b) 0\n                hp = rollingHash pat\n                m = k ^ lp\n                get = fromIntegral . unsafeIndex src\n                search !hs !i\n                  | hp == hs && pat == unsafeTake lp b = u\n                  | length src <= i = (src, empty)\n                  | otherwise = search hs' (i + 1)\n                  where u@(_, b) = unsafeSplitAt (i - lp) src\n                        hs' = hs * k + get i - m * get (i - lp)\n        \n        {-# INLINE karpRabin #-}\n        \n        shift :: ByteString -> (ByteString, ByteString)\n        shift !src\n          | length src < lp = (src, empty)\n          | otherwise = search (intoWord $ unsafeTake lp src) lp\n          where intoWord :: ByteString -> Word\n                intoWord = foldl' (\\ w b -> (w `shiftL` 8) .|. fromIntegral b) 0\n                wp = intoWord pat\n                mask = (1 `shiftL` (8 * lp)) - 1\n                search !w !i\n                  | w == wp = unsafeSplitAt (i - lp) src\n                  | length src <= i = (src, empty)\n                  | otherwise = search w' (i + 1)\n                  where b = fromIntegral (unsafeIndex src i)\n                        w' = mask .&. ((w `shiftL` 8) .|. b)\n        \n        {-# INLINE shift #-}"],"instances":[],"language":{"extensions":["MagicHash","UnboxedTuples","NamedFieldPuns","BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}