{"sliceID":425907407705908957,"uses":[{"reference":{"otherSlice":5831756764704217508},"usedName":{"valueName":{"identifier":"mallocByteString"}},"qualification":null},{"reference":{"builtinModule":"Foreign.ForeignPtr"},"usedName":{"valueName":{"identifier":"withForeignPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"assert"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$!"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"constructorName":{"identifier":"PS"},"constructorTypeName":{"identifier":"ByteString"}},"qualification":null},{"reference":{"otherSlice":3730763711957041450},"usedName":{"valueName":{"identifier":"create"}},"qualification":null},{"reference":{"otherSlice":811219613042846892},"usedName":{"valueName":{"identifier":"memcpy"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"typeName":{"identifier":"Ptr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":4942888801223460576},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null}],"fragment":["createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString","createAndTrim l f\n  = do fp <- mallocByteString l\n       withForeignPtr fp $\n         \\ p ->\n           do l' <- f p\n              if assert (l' <= l) $ l' >= l then return $! PS fp 0 l else\n                create l' $ \\ p' -> memcpy p' p l'"],"instances":[],"language":{"extensions":["ForeignFunctionInterface","BangPatterns","UnliftedFFITypes","MagicHash","UnboxedTuples","DeriveDataTypeable","Unsafe","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}