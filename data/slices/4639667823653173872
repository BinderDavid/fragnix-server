{"sliceID":4639667823653173872,"uses":[{"reference":{"builtinModule":"GHC.Integer.GMP.Internals"},"usedName":{"constructorName":{"identifier":"S#"},"constructorTypeName":{"identifier":"Integer"}},"qualification":null},{"reference":{"otherSlice":956356273154969218},"usedName":{"valueName":{"identifier":"intDec"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"I#"},"constructorTypeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":7960468724857315482},"usedName":{"valueName":{"identifier":"primFixed"}},"qualification":"P"},{"reference":{"otherSlice":2125063406135791585},"usedName":{"valueName":{"identifier":"char8"}},"qualification":"P"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"mappend"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Integer.GMP.Internals"},"usedName":{"typeName":{"identifier":"Integer"}},"qualification":null},{"reference":{"otherSlice":8984783929342293342},"usedName":{"typeName":{"identifier":"Builder"}},"qualification":null},{"reference":{"otherSlice":4470542753169268181},"usedName":{"valueName":{"identifier":"maxPow10"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"identifier":"fromInteger"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"otherSlice":190511337687050148},"usedName":{"valueName":{"identifier":"primMapListBounded"}},"qualification":"P"},{"reference":{"otherSlice":6877397957880357236},"usedName":{"valueName":{"identifier":"intDecPadded"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"builtinModule":"GHC.Integer.Type"},"usedName":{"valueName":{"identifier":"quotRemInteger"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null}],"fragment":["integerDec :: Integer -> Builder","integerDec (S# i#) = intDec (I# i#)\nintegerDec i\n  | i < 0 = P.primFixed P.char8 '-' `mappend` go (-i)\n  | otherwise = go (i)\n  where errImpossible fun\n          = error $ \"integerDec: \" ++ fun ++ \": the impossible happened.\"\n        \n        go :: Integer -> Builder\n        go n\n          | n < maxPow10 = intDec (fromInteger n)\n          | otherwise =\n            case putH (splitf (maxPow10 * maxPow10) n) of\n                (x : xs) -> intDec x `mappend` P.primMapListBounded intDecPadded xs\n                [] -> errImpossible \"integerDec: go\"\n        \n        splitf :: Integer -> Integer -> [Integer]\n        splitf pow10 n0\n          | pow10 > n0 = [n0]\n          | otherwise = splith (splitf (pow10 * pow10) n0)\n          where splith [] = errImpossible \"splith\"\n                splith (n : ns)\n                  = case n `quotRemInteger` pow10 of\n                        (# q, r #) | q > 0 -> q : r : splitb ns\n                                   | otherwise -> r : splitb ns\n                splitb [] = []\n                splitb (n : ns)\n                  = case n `quotRemInteger` pow10 of\n                        (# q, r #) -> q : r : splitb ns\n        \n        putH :: [Integer] -> [Int]\n        putH [] = errImpossible \"putH\"\n        putH (n : ns)\n          = case n `quotRemInteger` maxPow10 of\n                (# x, y #) | q > 0 -> q : r : putB ns\n                           | otherwise -> r : putB ns\n                  where q = fromInteger x\n                        r = fromInteger y\n        \n        putB :: [Integer] -> [Int]\n        putB [] = []\n        putB (n : ns)\n          = case n `quotRemInteger` maxPow10 of\n                (# q, r #) -> fromInteger q : fromInteger r : putB ns"],"instances":[],"language":{"extensions":["ScopedTypeVariables","ForeignFunctionInterface","MagicHash","UnboxedTuples","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"]}}